(in-package :beh);;; works pretty well, except the centering can look kind of funny;;; still needs a way to set the :multiple tag for args and a way to process the blocks...(defform (if agent          :block-class agent-block          :layout ((:when condition)                   (:then action)))         (condition (action action :multiple))  )(defmethod fill-argument-block* ((container form-block) (arg arg-block) (filler form-block))  (setf (actual arg) filler)  (sound-play-async *drop-in-sound*)  (set-view-position filler (view-position arg))  (set-view-container filler container)  ;; get rid of arg block, but save it   (unless (eq :multiple (third (arg arg)))    (set-view-container arg nil))  (setf (tag filler) (tag arg))  (push (cons filler arg) (slot-value container 'saved-holes))  (invalidate-view container t)     ; shouldn't be necessary  (block-changed filler)  )(defmethod layout-row ((block layout-block) row-spec top)  (flet ((find-block (spec)           (find-blocks-from-spec block spec)))    (position-row block (mapcar #'find-block row-spec) top row-spec)));;; return single block or list(defmethod find-blocks-from-spec ((container layout-block) spec)  (let* ((name (keyword (if (listp spec) (car spec) spec)))         (result nil))    (dosequence (sv (view-subviews container))      (when (and (typep sv 'layout-block)                 (eq (tag sv) name))        (push sv result)))    (case  (length result)      (0 (error "no block named ~A in ~A" name container))      (1 (car result))      (t (stable-sort (nreverse result) #'< :key #'(lambda (b) (if (typep b 'arg-block) 1 0))))))); +++ to utils(defun sum (list &key (key #'identity))  (apply #'+ (mapcar key list)))(defmethod position-row ((block layout-block) row-views top &optional (row-spec (make-list (length row-views))))  (let ((row-height (maximize row-views                              :key #'(lambda (v)                                        (if (listp v)                                         (sum v :key #'(lambda (vv)                                                          (+ *spacing*                                                            (point-v (view-size vv)))))                                         (point-v (view-size v))))                              :return-max t) )        (x *spacing*))    (mapcar #'(lambda (block spec)                (if (listp block)                  (let ((y top)                        (max-width 0))                    (dolist (iblock block)                      (set-view-position iblock (make-point x y))                      (incf y (+ (point-v (view-size iblock)) *spacing*))                      (setf max-width (max max-width (point-h (view-size iblock)))))                    (setf x (+ *spacing* max-width)))                  (setf x (+ *spacing* (position-subblock block spec top x row-height)))))            row-views            row-spec)    (values (+ top row-height))))(defmethod position-subblock ((block layout-block) spec top left row-height)  (set-view-position block (make-point left (+ top                                               (round (- row-height (point-v (view-size block)))                                                      2))))  (values (+ left (point-h (view-size block)))))