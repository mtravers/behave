(in-package :beh)#|;;; old(define-syntax action (go direction amount)  `(go ,(parse-type 'direction direction)        ,(parse-type 'number amount)));;; New(defblock action (go (direction direction) (amount number))     ; or (go direction (amount number))  `(go ,direction ,number))or(defform (go action) ((direction direction) (amount number))     ; or (go direction (amount number))  `(go ,direction ,number))|#(defclass form ()  ((name :reader name :initarg :name)   (type :initarg :type)   (args :initarg :args :reader args)   (body :initarg :body :reader body)))(defvar *all-types* nil)(defmacro defform ((name type) arglist &body body)  `(defform-1 ',name ',type ',arglist ',body))(defun defform-1 (name type args body)  (awhen (find name             (get type :xtranslations) :key #'name)    (deletef it (get type :xtranslations)))  (pushnew type *all-types*)  (let ((form (make-instance 'form                :name name                :type type                :args (mapcar #'(lambda (argdef)                                  (if (symbolp argdef)                                    (list argdef argdef)                                    argdef))                              args)                :body body)))    (push form (get type :xtranslations))    form))(defun parse-type (type thing)  ;; handle special cases  (case type    (number (when (numberp thing)              (return-from parse-type thing)))    (primitive     (return-from parse-type thing)))  (dolist (translation (get type :xtranslations)                       ; +++ should be done as handler                       (progn                         (warn "In (~A ~A), can't parse ~a as ~a" (name-of *agent*) (name-of *species*) thing type)                         (setf (compiled-ok? *agent*) nil)                         nil))    (when (and (listp thing)               (eq (car thing)                   (name translation)))      (unless (= (1- (length thing)) (length (args translation)))        (warn "In (~A ~A), wrong number of arguments in ~A" (name-of *agent*) (name-of *species*) thing)        (setf (compiled-ok? *agent*) nil))      (progv (mapcar #'car (args translation))             (mapcar #'(lambda (arg term)                         (parse-type (cadr arg)                                     term))                     (args translation)                     (cdr thing))        (return (eval (car (body translation))))))))      ; +++ only using first form of body#|;;; generalized version;;; doesn't handle numbers or prims yet(defun walk-type (type thing func)  ;; handle special cases  (case type    (number (when (numberp thing)              (return-from walk-type thing)))    (primitive     (return-from walk-type thing)))  (dolist (translation (get type :xtranslations)                       ; +++ should be done as handler                       (progn                         (warn "In (~A ~A), can't parse ~a as ~a" (name-of *agent*) (name-of *species*) thing type)                         (setf (compiled-ok? *agent*) nil)                         nil))    (when (and (listp thing)               (eq (car thing)                   (name translation)))      (unless (= (1- (length thing)) (length (args translation)))        (warn "In (~A ~A), wrong number of arguments in ~A" (name-of *agent*) (name-of *species*) thing)        (setf (compiled-ok? *agent*) nil))      (return (funcall func thing translation)))))      ; +++ only using first form of body(defun parse-type (type thing)  (walk-type type thing             #'(lambda (thing translation)                 (progv (mapcar #'car (args translation))                        (mapcar #'(lambda (arg term)                                    (parse-type (cadr arg)                                                term))                                (args translation)                                (cdr thing))                   (eval (car (body translation)))))))|#;;; The definitions(defform (always condition) ()  'true)(defform (near condition) (specifier (range number))        ; specifier == (specifier specifier)  `(u::near ,specifier ,range))(defform (on condition) (specifier)  `(u::on ,specifier))(defform (a specifier) ((breed primitive))       ; +++  (sl-symbol breed))(defun sl-symbol (symbol)  (intern (symbol-name symbol) :u))(defform (go action) (direction (amount number))  `(go ,direction ,amount));;; scale these by /10 (defform (turn action) ((amount number))  `(rt ,amount))(defform (fd action) ((amount number))  `(fd ,amount))(defform (eat action) (thing)  `(u::eat ,thing))(defform (randomly direction) ()  '(random 360))                        ; do we need to scale number?  (defform (towards direction) (thing)  `(towards-thing ,thing))(defform (away-from direction) (thing)  `(away-from-thing ,thing))(defform (it thing) ()  (turtle-var 'it))(defun turtle-var (name)  `(u::.thing ,(+ 1 (position name *built-in-variables*))))(defform (a-random thing) ((species specifier))  `(U::%one-of-random-breeds ,species));;; some constant headings(defform (east direction) ()  90)(defform (random number) ((range number))  `(frandom ,range))(defform (arand number) ((range number))  `(arandf ,number));;; The graphics(defun def-beh-type (name color)  (setf (get name :color) color))(defun type-color (type)  (or (get type :color)      *gray-color*))(def-beh-type 'action (hsv-to-color 0 .5 .7))(def-beh-type 'thing (hsv-to-color .2 .5 .7))(def-beh-type 'number (hsv-to-color .4 .5 .7))(def-beh-type 'direction (hsv-to-color .6 .5 .7))(def-beh-type 'condition (hsv-to-color .8 .5 .7))(defun sym-string (sym)  (nsubstitute #\Space #\- (string-downcase (symbol-name sym))))(defmethod* generate-block ((form form))  (let ((block (make-instance 'block                 :view-container w                 :view-position #@(20 20)                 :color (type-color type)                 :text (sym-string name))))    (dolist (arg args)      (make-instance 'hole        :view-container block        :view-position #@(20 20)        :text (sym-string (car arg))        :color (type-color (cadr arg))))))(defun generate-all-blocks ()  (dolist (type *all-types*)    (dolist (form (get type :xtranslations))      (generate-block form))))