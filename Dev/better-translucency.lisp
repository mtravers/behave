(in-package :beh);;; try to do translucency right;;; This almost works, but the inner blocks don't get drawn because ;;; they change their focus.  Foo.;;; OK, that's fixed, but items dragged off the palette don't work because they;;; haven't been drawn on the main sheet yet. Argh.;;; another bug: when a block is pulled out of a hole, white turds are left.;;; Italics indicate code that does NOT cause this bug.(defclass translucency-world (ccl::gworld)  ((valid-for :initform nil :accessor valid-for)))(defvar *drawing-into-translucency-world* nil)(defmethod snapshot ((gw translucency-world) view)  (unless (eq (valid-for gw) view)    (let ((size-needed (point-max (view-size view) (ccl::size gw))))      (unless (eql size-needed (ccl::size gw))        (ccl::update-gworld gw :size size-needed)))    (ccl::with-sheets-focused-gworld (gw)      (let ((*drawing-into-translucency-world* t))        (view-draw-contents view)))    (setf (valid-for gw) view)));;; alternate method (simpler);;; but not yet working (see *** below)(defmethod snapshot ((gw translucency-world) view)  (unless (eq (valid-for gw) view)    (let ((size-needed (point-max (view-size view) (ccl::size gw))))      (unless (eql size-needed (ccl::size gw))        (ccl::update-gworld gw :size size-needed)))    (let* ((vsheet (ccl::view-sheet view))           (vtopleft (mt:view-position-relative view vsheet))           (vbotright (add-points (view-size view) vtopleft)))      (ccl::with-pixmap (vpm vsheet)        (ccl::with-pixmap (gpm gw)          (with-pointers ((source vpm)                          (dest gpm))            (with-rect (rsource vtopleft vbotright)              (with-rect (rdest 0 (view-size view))                (#_CopyBits source dest rsource rdest #$patcopy (%null-ptr))))))))    (setf (valid-for gw) view)))(defmethod view-invalidated ((gw translucency-world) view)  (when (eq (valid-for gw) view)    (setf (valid-for gw) nil)))  (defvar *translucent-world* (make-instance 'translucency-world))(defclass translucent-mixin (simple-view)  ((translucent? :initform nil :accessor translucent?)))(defparameter *translucent-blend-fraction* .5)(defmethod* view-draw-contents :around ((v translucent-mixin))  (if (and translucent? (not *drawing-into-translucency-world*))    (progn       (snapshot *translucent-world* v)      (with-rgb (blend (make-gray (round (* 255 *translucent-blend-fraction*))))          ; Ah, at last, here's how to do it right!        (#_OpColor blend))      (ccl::with-pixmap (spm *translucent-world*)        (ccl:with-pointers ((source spm)                            (dest (ccl:rref wptr windowrecord.portbits)))          (with-rect (srcrect 0 (view-size v))            (#_CopyBits source dest             srcrect srcrect #$blend (%null-ptr))))))    (call-next-method)))(defmethod invalidate-region :after ((v translucent-mixin) region &optional erase-p)  (declare (ignore region erase-p))  (view-invalidated *translucent-world* v))(defmethod* drag-and-drop :around ((v translucent-mixin) &optional ignore)  (snapshot *translucent-world*  v)     ; *** this makes it work (but not for palette drag, for obvious reasons)  (setf translucent? t)  (call-next-method)  (setf translucent? nil))