;;; doesn't work, because ccl::view-find-vacant-position does;;; not expand blocks...argh. Didn't I deal with this in liveworld(defmethod vacate ((v view))  (dosequence (sv (view-subviews v))    (unless (typep sv 'block-text-subview)      (let ((new-pos (ccl::view-find-vacant-position v sv) ))        (unless (zerop new-pos)          (set-view-position sv new-pos))))))#|(generate-all-blocks)(dosequence (sv (view-subviews w))  (vacate sv))(vacate w);;; look what I found from LW(dosequence (sv (view-subviews *win*))  (cleanup sv))(cleanup *win*)|#(defmethod cleanup ((box basic-block))  (progn ; delay-views     (dosequence (v (view-subviews box))      (when (typep v 'basic-block)        (when (view-overlaps? v)          (find-position v))))))(defmethod relayout ((box basic-block));  (ungrow box)  (dosequence (v (view-subviews box))    (set-view-position v (top-usable-box-position)))  (cleanup box))(defmethod view-overlaps? ((v simple-view))  (dosequence (sv (view-subviews (view-container v)) nil)    (unless (eq sv v)      (when (views-overlap? v sv)        (return t)))))(defmethod views-overlap? ((v1 view) (v2 view))  (with-rect (r1 (view-position v1) (add-points (view-position v1) (view-size v1)))    (with-rect (r2 (view-position v2) (add-points (view-position v2) (view-size v2)))      (#_SectRect r1 r2 r2))))(defun boxp (thing) (typep thing 'proto-block));;; new method, will extend horizontally (still not smart)(defmethod* find-position ((box proto-block))  (let ((pos (view-find-vacant-position view-container box #'boxp)))      ; +++ not quite the right thing    (if (zerop pos)      ;; no room, extend container vertically (+++ this is lame algorithm)      (if (> (view-aspect-ratio (view-container box)) 1.75)        ;; extend horizontally        (setf pos              (view-find-vacant-position               view-container box #'boxp               (add-points (view-size view-container) (make-point (point-h (view-size box)) 0))))        ;; extend vertically        (setf pos (view-find-vacant-position                   view-container box #'boxp                   (add-points (add-points (view-size view-container) (top-usable-box-position))                               (make-point 0 (point-v (view-size box))))))))    (set-view-position box pos)))(defun top-usable-box-position () (make-point 4 4))(defmethod* view-aspect-ratio ((v view))  (/ (point-v view-size) (point-h view-size)))(defmethod view-find-vacant-position ((view view) subview &optional (subview-filter #'identity) (w-size (view-size view)))  (let* ((size (view-size subview))         (height (point-v size))         (width (point-h size));         (w-size (view-size view))         (w-height (point-v w-size))         (w-width (point-h w-size))         (rect-rgn ccl::*temp-rgn*)         (vacant-rgn ccl::*temp-rgn-2*)         (top-pos (top-usable-box-position))         (v-list (list (point-v top-pos)))         (h-list (list (point-h top-pos))))    (unwind-protect      (progn        (rlet ((s-rect :rect :topleft (top-usable-box-position) :bottomright w-size))          (#_RectRgn vacant-rgn s-rect)          (dovector (item (view-subviews view))            (when (funcall subview-filter item)            (let ((position (view-position item))                  (size (view-size item)))              (unless (or (eq item subview) (not position))                (unless size                  (setq size                        (setf (slot-value item 'size) (view-default-size item))))                (let ((lower-right (add-points position size)))                  (rset s-rect :rect.topleft position)                  (rset s-rect :rect.bottomright lower-right));                (#_InsetRect s-rect -1 -1)                (#_RectRgn rect-rgn s-rect)                (#_DiffRgn vacant-rgn rect-rgn vacant-rgn)                (pushnew (+ 1 (rref s-rect :rect.right)) h-list)                (pushnew (+ 1 (rref s-rect :rect.bottom)) v-list)))))          (setq v-list (sort v-list #'<)                h-list (sort h-list #'<))          (dolist (v v-list)            (dolist (h h-list)              (#_SetRectRgn rect-rgn h v (+ h width) (+ v height))              (#_UnionRgn  vacant-rgn rect-rgn rect-rgn)              (when (and (#_EqualRgn rect-rgn vacant-rgn)                         (< (+ v height) w-height)                         (< (+ h width) w-width))               (return-from view-find-vacant-position (make-point h v))))))        (return-from view-find-vacant-position #@(0 0))))))