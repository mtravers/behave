(in-package :beh);;; these should be interchangeable; (require :mactcp)(require :opentransport)(defparameter *vft-host* "michelangelo.media.mit.edu");(defparameter *vft-host* (ccl::tcp-host-cname ""))      ; use local host (defparameter *vft-port* 222);;; tcm; +++ look into notify-proc!!!;;; This version keeps a stream open(defvar *vft-stream* nil)(defvar *vft-debug* t)(defvar *vft-standalone* nil)(defun vft-out (command &optional response?)  (progn ; report-and-ignore-errors    (unless *vft-standalone*      (establish-tcp-stream)      ;  (ccl::telnet-write-line *vft-stream* "~A" command)      (princ-stripped command *vft-stream*)      (write-char #\CR *vft-stream*)      (write-char #\LF *vft-stream*)      (force-output *vft-stream*))    (when *vft-debug*      (at-listener-level        (format t "~%VFT<-: ~:W" command)))    (let ((reply (if *vft-standalone*                   (if response? (gensym "TOKEN") nil)                   (ignore-errors                     (read-from-string (ccl::telnet-read-line *vft-stream*))))))      (when (and *vft-debug* reply)        (at-listener-level          (format t "~%VFT->: ~:W" reply)))      reply)))(defun establish-tcp-stream ()  (unless (and *vft-stream*               #-:mactcp-compatibility               (case (ccl::tcp-state-name (ccl::tcp-connection-state *vft-stream*))                 (:established t)                 (:closed nil)                 (t nil)))              ; should close the stream, but it tends to hang    #-:mactcp-compatibility    (when *vft-debug*      (at-listener-level        (format t "~%Making new TCP stream, old state is ~A" (and *vft-stream* (ccl::tcp-state-name (ccl::tcp-connection-state *vft-stream*))))))    (setf *vft-stream* (open-tcp-stream *vft-host* *vft-port*))))(defun princ-stripped (thing stream)  (cond ((null thing))        ((listp thing)         (princ-stripped (car thing) stream)         (write-char #\Space stream)         (princ-stripped (cdr thing) stream))        (t (princ thing stream))));;; Let a process manage the TCP connection;;; queue elements are (<exp> <continuation>), where <cont> is nil or a procedure to be ;;; called with a value.(defvar *tcp-queue* nil)(defun vft-command (command &optional cont)  (without-interrupts   (if (or cont (null *tcp-queue*))     (push (list command cont) *tcp-queue*)     ; if a response is expected, move to front of queue     (rplacd (last *tcp-queue*)             (list (list command cont))))))(defun remove-vft-commands (filter-proc)  (without-interrupts   (setf *tcp-queue*          (filter-out filter-proc *tcp-queue*))))(defun manage-tcp-connection ()  (do (elem response) (())    (report-and-ignore-errors     (process-wait "TCP Manager" #'(lambda () *tcp-queue*))     (setf elem (pop *tcp-queue*))       (setf response (vft-out (first elem) (second elem)))     (awhen (second elem)       (funcall it response)))))(u::now-and-on-startup (tcp-manager)  (process-run-function "TCP/VFT manager" #'manage-tcp-connection))(defmethod* initialize-instance :after ((s vft-species) &rest ignore)  (vft-command 'NewBehavior #'(lambda (result)                                (setf token result))))(defmethod* register-behavior ((s vft-species))  (vft-command `(SetBehavior ,token                             ,@(mapcar #'compile-agent                                       (filter #'agent-active? (species-agents s)))          ; +++ may not need to call compile agent here                             NoMoreSubBehaviors)))(defmethod create-a ((s symbol))  (create-a (species-named s)))(defmethod* create-a ((s vft-species))  (vft-command `(AddCreature ,shape BehaviorToken ,token color ,color)))       ; breed to follow(defun reset-tank ()  (vft-command `EmptyTank))(defun standalone ()  (setf *vft-standalone* t))(defun use-host (host)  (setf *vft-standalone* nil        *vft-host* host        *vft-stream* nil))  