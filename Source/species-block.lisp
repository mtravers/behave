(in-package :beh)#| ######################################################################Support for species blocksPart of the Behave! systemCopyright © 1996-7 Michael Travers Send questions, comments, and fixes to mt@media.mit.edu.###################################################################### |#(def-beh-type 'species (hsv-to-color 0 0 .8))(defform (fish species :block-class species-block) (agent)  )(defclass* species-block (form-block expand-container-mixin)  ((species :initarg :species :accessor species))  (:default-initargs     :view-font (append *default-block-font* '(:outline))    :color (make-gray 175)    ))(defclass* create-button (layout-block ccl::momentary-pict-button gesture-handling-mixin proto-block)  ()  (:default-initargs    :pict (get-resource :pict 212)    :pict-pressed (get-resource :pict 213)))  ;;; treat these as regular clicks here; the keys are processed in the PRESS method(defmethod option-click ((b create-button) where)  (click b where))(defmethod option-shift-click ((b create-button) where)  (click b where))(defmethod ccl::press ((b create-button))  (call-next-method)  (let ((species (species (view-container b))))    (create-creatures species                       (cond ((and (option-key-p) (shift-key-p)) 100)                            ((option-key-p) 10)                            (t 1)))))(defclass* reset-button (layout-block ccl::momentary-pict-button gesture-handling-mixin proto-block)  ()  (:default-initargs    :pict (get-resource :pict 214)    :pict-pressed (get-resource :pict 215)))  (defmethod ccl::press ((b reset-button))  (call-next-method)  (at-listener-level    (reset-block (view-container b))))(defmethod* make-block ((s species))  (make-species-block name-of))(defun make-species-block (name)  (let ((sb (generate-block             (defform-1 name 'species '(agent) 'nil 'species-block 'nil t)             :species name)))    (find-position sb)    sb))(defmethod* create-subviews :after ((block species-block))  (when (slot-boundp block 'species)    (let ((pict (slot-value (species-named species) 'pict)))      (when pict        (make-instance 'block-pict-subview          :view-container block          :pict pict))      (make-instance 'create-button        :view-container block)      (make-instance 'reset-button        :view-container block)      ;    (layout-block sb)      ;    (find-position sb)      )))(defform (new-species species :block-class species-block) (agent)  );;; replaces more complex version in cleanup.lisp(defun find-position (block)  (let ((pos (ccl::view-find-vacant-position (view-container block) block)))    (set-view-position block pos)))(defun make-species-blocks ()  (mapc #'make-species-block* (all-species)))(defmethod* make-species-block* ((s species))  (let ((sb (generate-block             (defform-1 name-of 'species '(agent) nil 'species-block nil nil)             :species name-of)))    (when pict      (make-instance 'block-pict-subview        :view-container sb        :pict pict))    (make-instance 'create-button      :view-container sb)    (make-instance 'reset-button      :view-container sb)    (layout-block sb)    (find-position sb)    sb));;; special layout for species blocks;;; new version, try to keep holes in right place during a drag.(defmethod layout-block ((block species-block) &optional ignore)  (flet ((find-block (type)           (dosequence (sv (view-subviews block))             (when (typep sv type)               (return sv))))         (list-nonnull (&rest args)           (filter #'identity args)))    (let* ((name-block (find-block 'block-text-subview))           (pict-block (find-block 'block-pict-subview))           (create-button (find-block 'create-button))           (reset-button (find-block 'reset-button))           (arg-block (find-block 'arg-block))           (agent-blocks (nset-difference (coerce (view-subviews block) 'list)                                          (list-nonnull create-button reset-button name-block pict-block arg-block)))           (agent-block-list            (if (mouse-down-p)              (sort (cons arg-block agent-blocks) #'< :key #'(lambda (block) (point-v (view-position block))))              (nconc (sort agent-blocks #'< :key #'(lambda (block) (point-v (view-position block))))                      (list arg-block))))           (y *spacing*))      (setf y (+ *spacing* (position-row block (list-nonnull name-block pict-block create-button reset-button) y)))      (dolist (agent-block agent-block-list)        (setf y (+ *spacing* (position-row block (list agent-block) y)))))    (shrink-wrap block *spacing*)))(defmethod fill-argument-block* :after ((container species-block) (arg arg-block) (filler form-block))  (setf (species filler)        (species container))  ;; sort of a crock...retrieve the hole and use it again  (set-view-container arg container)  (relayout container));;; override drag-and-drop(defmethod click ((b species-block) where)  (drag b where)  t)(defmethod* reset-block ((sb species-block))  (dosequence (v (view-subviews sb))    (when (and (typep v 'form-block)               (eq (tag v) :agent))      (kill-block v)))  (without-interrupts   (fill-species-block sb (species-named species))))    (defmethod kill-block ((b form-block))  (raise b)  (set-view-container b nil))