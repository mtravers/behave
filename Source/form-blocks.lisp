(in-package :beh)#| ######################################################################Support for form blocksCopyright © 1996-7 Michael TraversPart of the Behave! systemSend questions, comments, and fixes to mt@media.mit.edu.###################################################################### |#;;; Connect language to graphics(defun def-beh-type (name color)  (setf (get name :color) color))(defun type-color (type)  (or (get type :color)      *gray-color*))#|(def-beh-type 'action (hsv-to-color 0 .5 .7))(def-beh-type 'thing (hsv-to-color .2 .5 .7))(def-beh-type 'number (hsv-to-color .4 .5 .7))(def-beh-type 'direction (hsv-to-color .6 .5 .7))(def-beh-type 'condition (hsv-to-color .8 .5 .7))|#(defun assign-type-colors (types saturation value)  (let ((ntypes (length types)))    (do ((rest types (cdr rest))         (hue 0 (+ hue (/ ntypes))))        ((null rest))      (def-beh-type (car rest) (hsv-to-color hue saturation value)))))(assign-type-colors '(action thing number direction condition specifier breed) .5 .8)(defun sym-string (sym)  (etypecase sym    (symbol (nsubstitute #\Space #\- (string-downcase (symbol-name sym))))))(defclass* form-block (a-block)  ((form :initarg :form :reader form)   ; form object we represent   (saved-holes :initform nil)   (mode :initarg :mode :initform nil)))        ; flag for palettes and other odditites(defmethod* print-object ((fb form-block) stream)  (print-unreadable-object (fb stream :identity t :type t)    (format stream "~A" (name form))))(defclass* arg-block (hole)  ((arg :initarg :arg :reader arg)                  ; arg we represent   (actual :initform nil :accessor actual)))             ; the actual block(defmethod* initialize-instance :after ((block arg-block) &rest ignore)  (make-instance 'block-text-subview    :text (sym-string (car arg))    :text-color (default-text-color block)    :view-container block    :view-font (delete :outline (view-font block))    :view-position (make-point (max 2 bevel-border) (max 2 bevel-border))))(defmethod print-object ((ab arg-block) stream)  (print-unreadable-object (ab stream :identity t :type t)    (format stream "~A" (arg ab))))(defmethod* generate-block ((form form) &rest other-args)  (let ((block (apply #'make-instance (block-class form)                      :form form                      :color (type-color type)                      other-args)))    block));;; Adjusting dragging and dropping to work right.(defmethod can-drop? ((block a-block) (target hole))  (eq (type (form block))     ; type checking is here.      (cadr (arg target))));;; not sure what's right here.  We don't need the hole anymore for display,;;; but if the block is removed...also there is the layout thing.;;; replacement(defmethod drop ((block form-block))  (drop-in block (drop-target block)))(defmethod drop-in ((block form-block) (hole arg-block))  (play-sound *drop-in-sound*)  (fill-argument-block* (view-container hole) hole block))(defmethod drop-in ((block form-block) (target null))  (when (view-contained-by? block (view-window *win*))    (reseat-view block *win*)    ))(defmethod fill-argument-block* ((container form-block) (arg arg-block)                                     (filler form-block))  (setf (actual arg) filler)  (set-view-position filler (view-position arg))  (set-view-container filler container)  ;; get rid of arg block, but save it  (unless (eq :multiple (third (arg arg)))    (set-view-container arg nil))  (setf (tag filler) (tag arg))  (push (cons filler arg) (slot-value container 'saved-holes))  (invalidate-view container t)     ; shouldn't be necessary  )(defmethod fill-argument-block* :around ((container form-block) (arg arg-block) (filler form-block))  (call-next-method)  (block-changed filler));;; +++ warning: this is slow (not presently used)(defmethod elevate-view ((view view))  (set-view-level view 0)  (elevate-view (view-container view)))(defmethod elevate-view ((view t)) );;; put hole back(defmethod raise :around ((block form-block))  (let ((container (view-container block)))    (call-next-method)    (when (typep container 'form-block)      (restore-hole container block)      (in-background "restore-hole"     ; let dragging start sooner...        (call-if #'relayout container)))))(defmethod raise :before ((block form-block))  (when (typep (view-container block) 'a-block)    (play-sound *pull-out-sound*)))(defmethod* restore-hole ((block form-block) removed-block)  (let* ((pair (assq removed-block saved-holes))         (hole (cdr pair)))    (when pair;;; nice idea but doesn't work;      (set-view-size hole (view-size removed-block));      (layout-block hole)      (set-view-container hole block)      (deletef pair saved-holes)      (invalidate-view block t)      ; shouldn't be necessary      (block-changed block))));;; pass changes up(defmethod block-changed ((block a-block))  (when (typep (view-container block) 'a-block)    (block-changed (view-container block))));; needs error handling;; new, gets args from saved holes, which is weird.(defmethod* generate-code ((block form-block))  (flet ((find-arg (arg)           (dosequence (pair saved-holes (error "No block found for ~A" arg))             (when (and (typep (cdr pair) 'arg-block)                        (eq (car (arg (cdr pair))) arg))               (return (actual (cdr pair))))))         ;; for multiple args         (find-args (arg &aux result)           (dosequence (v (view-subviews block) (or result (error "No block found for ~A" arg)))             (when (and (typep v 'form-block)                        (eq (tag v) (keyword arg)))     ; +++ not sure about this               (push v result)))))    `(,(name form)      ,@(mapcan #'(lambda (argspec)                    (if (eq :multiple (third argspec))                      (mapcar #'generate-code (find-args (car argspec)))                      (list (generate-code                             (find-arg (car argspec))))))                (args form)))))(defmethod initialize-instance :after ((block form-block) &rest ignore)  (create-subviews block)  (layout-block block))(defmethod* clone-block ((block form-block))  (generate-block form))(defmethod clone-drag-and-drop ((block form-block) &optional (where #@(0 0)))  (at-listener-level    (let ((new-block (clone-block block)))      (play-sound *clone-sound*)      (drag-and-drop new-block where))))