;;; Underlying routines for behavior language;;; Conditionsto near :specifier :range   ifelse (:specifier = 9999)    [output near-mouse :range]    [setit the-closest :specifier     output :range > (distance-nowrap xcor-of it ycor-of it)]endto near-mouse :range  setit 9999  output :range > (distance-nowrap mouse-xcor mouse-ycor)endto the-closest :specifier  ifelse (:specifier < 0)    [setit who-min-of-turtles-with [true]  ; and not dead          [distance-nowrap xcor-of myself ycor-of myself]]    [setit who-min-of-turtles-with [breed = :specifier]  ; and not dead      [distance-nowrap xcor-of myself ycor-of myself]]  output itendto on :specifier  ifelse (:specifier = -1)    [setit one-of-turtles-here]    [ifelse (:specifier = 9999)       [setit mouse-here]       [setit %one-of-breeds-here :specifier]]  output it >= 0  endto mouse-here  output ifelse-report ((mouse-xcor = round xcor) and (mouse-ycor = round ycor))    [9999]    [-1]end  ;;; relative density of neighbors (for pond). I wonder if this should;;; be generalizedto neighbor-% :breed  setscratch1 0  setscratch2 0  count-neighbors breed -1 -1  count-neighbors breed -1  0  count-neighbors breed -1  1  count-neighbors breed  0 -1  count-neighbors breed  0  1  count-neighbors breed  1 -1  count-neighbors breed  1  0  count-neighbors breed  1  1  output (100 * (scratch2 / scratch1))endto count-neighbors :breed :dx :dy  setscratch1 scratch1 + count-turtles-at :dx :dy  setscratch2 scratch2 + %count-breeds-at :breed :dx :dyend;;; Movementto go-nowrap :direction :amount seth :direction fd-nowrap :amountendto go :direction :amount seth :direction fd :amountend;;; not usedto in-bounds? :x :y  output (    (:x <= screen-edge)          and (:y <= screen-edge)          and (:x >= (0 - screen-edge))          and (:y >= (0 - screen-edge)))endto fd-nowrap :amount setloopcount int :amount repeat loopcount  [jump-nowrap 1]  jump-nowrap (:amount - loopcount)endto jump-nowrap :amount  setxy screen-trim (xcor + (:amount * %dx))        screen-trim (ycor + (:amount * %dy))endto screen-trim :coord  output max (min :coord screen-edge) (0 - screen-edge)end;;; Directions; 9999 = number of the mouseto towards-thing :thing  ;; set it?  ifelse :thing = 9999     [output towards-nowrap mouse-xcor mouse-ycor]     [output towards-nowrap xcor-of :thing ycor-of :thing]endto away-from-thing :thing  output (180 + towards-thing :thing)end;;; New system for pseudo-thingsto mouse-thing  setit 7777  setscratch1 mouse-xcor   setscratch2 mouse-ycor  output 7777endto center-thing  setit 7777  setscratch1 0   setscratch2 0  output 7777endto towards-thing1 :thing  ;; set it?  ifelse (:thing = 7777)     [output towards-nowrap scratch1 scratch2]     [output towards-nowrap xcor-of :thing ycor-of :thing]endto away-from-thing1 :thing  output (180 + towards-thing1 :thing)end;;; Numbersto frandom :x  output (random (100 * :x)) / 100end;;; centered around 0to arandf :n  output (frandom (2 * :n)) - :nendto random-between :lo :hi  output :lo + frandom (:hi - :lo)end;;; Deathto eat :prey  setdead-of :prey trueendto die-demon  if dead [die]                         ; more fanciful stuff is possible!end;;; New Deathto eat1* :prey  setdead-of :prey 100  setbreed-of :prey corpse  setscratch1 :prey                     ; debugend;;; ignore arg, always use itto eat1 :prey  setdead-of it 100  setbreed-of it corpseendto suicide  setdead 100  setbreed corpseendto die-demon1 ask-corpse [setc random 140  setdead dead - 1  if (dead <= 0) [die]]end;;; this only works by accident, I thinkto create-random :nbreed :n :ncolor  setscratch2 false  %create-breed :nbreed :n  if ((breed = :nbreed) and scratch2)    [setxy random screen-size random screen-size     setc :ncolor]end      ;;; following stuff is not used; near an individual -- not really what we wantto near* :creature :range  setit :creature  output (alive?-of :creature) and         :range > distance xcor-of :creature ycor-of :creatureendto pick :breed  setit %one-of-breeds :breed  output it >= 0end;;; every is now a primitive, and I'm not sure what this was supposed to be...I guess a predicateto every* :n output 0 = random :nend