(in-package :beh)#| ######################################################################View library, based on LiveWorld.Copyright © 1996-7 Michael Travers Send questions, comments, and fixes to mt@media.mit.edu.----------------------------------------------------------------Classes defined here:gesture-handling-mixin       handles chorded mouse-clicksdrag-mixin                   implements drag and grow commandsdrag-and-drop-mixinhighlight-mixinexpand-container-mixin       automatically expand container to include subviewstext-view                    a view designed for displaying a single fixed text stringpict-viewshadow-view                  a translucent shadow, used by drag-and-droptranslucent-mixin;;; Note: all views here are based on view rather than simple-view, just;;; to make coordinate handling consistent. ; +++ no optimization done, some stuff is going to be slow; +++ mixin for shrink-to-fit; +++ simple one-way constraint stuff for adjacency, etc.;;; Mouse click handling with gestures.;;; need to be able to pass things up to containing views;;; +++ actually, this sucks.  We should have real command tables that ;;; can generate pop-up menus, doc strings, wholines. ###################################################################### |#(defclass* colored-background-mixin (view)  ((background-color :initarg :background-color :initform *gray-color*)))(defmethod* view-draw-contents :before ((v colored-background-mixin))  (let* ((topleft (view-scroll-position v))         (botright (add-points topleft (view-size v))))    (with-rect (r topleft botright)      (with-rgb (c background-color)        (#_rgbForeColor c)        (#_PaintRect r)))))(defclass* gesture-handling-mixin (simple-view)          ; note, if this is based on view it won't work (clicks won't get passed to subviews)  ());;; undo an annoying alanism(defun ccl::debug-nudge-nudge () ());;; Note: click handlers must return a non-nil value to indicate they've done something!!!(defmethod view-click-event-handler ((v gesture-handling-mixin) where)  (or (handle-or-pass-up v where)      (call-next-method)));;; pass the click up the hierarchy looking for a handler.(defmethod handle-or-pass-up ((v gesture-handling-mixin) where)  (or (aand (click-handler v where)            (funcall it v where))       (handle-or-pass-up (view-container v) (add-points where (view-position v)))))(defmethod handle-or-pass-up ((v simple-view) where)  (handle-or-pass-up (view-container v) (add-points where (view-position v))))(defmethod handle-or-pass-up ((v null) where)  (declare (ignore where))  nil);;; returns a method name (or function object) that takes view and position args;;; NOTE: encapsulating a click handler will screw this up(defmethod click-handler ((v gesture-handling-mixin) where)  (let ((method-name (intern (modifier-key-name) #.*package*)))    (when (method-exists-p method-name v where)      method-name)))#|;;; here's a default delete command(defmethod command-option-control-click ((v gesture-handling-mixin) where)  (declare (ignore where))  (set-view-container v nil)  t)|#  (defun modifier-key-name ()  (let (#+CCL-3 (ccl::*control-key-mapping* nil))    (format nil "~:[~;COMMAND-~]~:[~;OPTION-~]~:[~;CONTROL-~]~:[~;SHIFT-~]~:[~;DOUBLE-~]CLICK"          (command-key-p)          (option-key-p)          (control-key-p)          (shift-key-p)          (double-click-p)          )));;; default double-click method, can be overridden if double-click has a ;;; hairier meaning. Actually, we need this for every possible;;; key combination, sigh.(defmethod double-click ((v gesture-handling-mixin) where)  (click v where)  (click v where))(defmethod click ((v gesture-handling-mixin) where)  (declare (ignore where))  nil);;; Provides mouse-driven dragging and growing;;; +++ support dragging multiple objects(defclass* drag-mixin (view)   ());;; these can be (and are) reset by an init.;(defvar *draggable-cursor* *arrow-cursor*);(defvar *dragging-cursor* *arrow-cursor*);(defvar *grow-cursor* *arrow-cursor*)(defmethod view-cursor ((v drag-mixin) point)  (declare (ignore point))  *draggable-cursor*)(defvar *dragged* nil)(defmacro with-mouse-dragging ((mouse-pos-var dragged-view) &body body)  `(let ((*dragged* ,dragged-view))     (with-mouse-tracking (,mouse-pos-var (view-container ,dragged-view))       ,@body)))(defmacro with-mouse-tracking ((mouse-pos-var within-view) &body body)  `(do ((,mouse-pos-var (view-mouse-position ,within-view)                        (view-mouse-position ,within-view))        (old-mouse-pos -999 ,mouse-pos-var)        (window (view-window ,within-view)))       ((not (mouse-down-p)))     (unless (= ,mouse-pos-var old-mouse-pos)       ,@body)     (window-update-event-handler window)     (process-allow-schedule)     ));;; plain old drag(defmethod drag ((v drag-mixin) &optional (where #@(0 0)))  (with-cursor *dragging-cursor*    (with-mouse-dragging (mouse-pos v)      (set-view-position v (point-max (subtract-points mouse-pos where) #@(0 0)))            ; max might want to be argument      )))(defmethod grow ((v drag-mixin) &optional (where #@(0 0)))  (let ((offset (subtract-points (view-size v)                                 (add-points where (view-position v)))))    (with-cursor *grow-cursor*      (with-mouse-dragging (mouse-pos v)        (set-view-size v (add-points mouse-pos offset))        (invalidate-view v)        ))));;; Default mouse gestures for drag-mixin (requires gesture-handling-mixin to work)#|;;; Default mouse gestures for drag-mixin (requires gesture-handling-mixin to work)(defmethod control-click ((v drag-mixin) where)  (drag v where)  t)(defmethod control-shift-click ((v drag-mixin) where)  (drag-and-drop v where)  t)(defmethod option-control-click ((v drag-mixin) where)  (grow v where)  t)(defmethod option-control-shift-click ((v drag-mixin) where)  (declare (ignore where))  (view-minimize v))|#;;; the default, but usually not the right thing.  Should do shrink-wrap(defmethod view-minimize ((v simple-view))  (set-view-size v (view-default-size v)));;; Pieces of text; +++ change size when text or font changes?(defclass* text-view (view)   ((text :initarg :text :initform nil :reader text)   (text-color :initarg :text-color :initform 0)))(defmethod* raw-set-font ((v simple-view) font)  (multiple-value-bind (ff ms) (font-codes font)    (when ff      (set-wptr-font-codes wptr ff ms))))(defmethod* set-text ((v text-view) new-text)  (setf text new-text)  (set-view-size v (point-max view-size (view-default-size v)))  (invalidate-view v))(defmethod* view-draw-contents :after ((v text-view))  (when text    (with-rgb (c text-color)      (#_rgbForeColor c))    (raw-set-font v (view-font v))       ; +++ inefficient to call view-font a lot, offset should be param somewhere    (#_MoveTo 0     (font-info (view-font v)))        ; +++ must be smarter about position    (with-pstrs ((ps text))      (#_DrawString ps))))(defun font-height (font)  (multiple-value-bind (ascent descent) (font-info font)    (+ ascent descent)))(defmethod* view-default-size ((v text-view))  (with-font-focused-view v    (with-pstrs ((ps text))      (make-point (1+ (#_StringWidth ps))       ; the +1 is needed for antialiased fonts                  (font-height (view-font v))))));;; see pict-dialog-item in pixmap-utils(defclass* pict-view (view)  ((pict :initarg :pict :initform nil)))(defmethod* view-default-size ((v pict-view))  (when pict    (subtract-points (rref pict picture.picframe.bottomright)                     (rref pict picture.picframe.topleft))))(defmethod* view-draw-contents ((v pict-view))  (let* ((topleft #@(0 0))         (bottomright view-size))    (rlet ((dest-rect rect                      :topleft topleft :bottomright bottomright))      (#_DrawPicture pict dest-rect))))#|;;; This presumes the pixmap is a screen buffer, and isn't in use somewhere else.(defmethod* remove-view-from-window ((pdi pict-dialog-item))  (if dispose    (#_KillPicture pict))  (call-next-method))|#;;; Expand container to fit when size or position changes; +++ corresponding shrink-to-fit mixin (or, do you ever want shrink without expand?); +++ does nothing to stop a user from shrinking a container so it doesn't include its subviews; +++ shouldn't containers decide whether or not to expand, rather than subviews?  But then; notification is a problem(defclass* expand-container-mixin (view)   ((border :initform 4 :initarg :border)))(defmethod* set-view-position :after ((view expand-container-mixin) h &optional v)  (declare (ignore h v))  (expand-to-fit (view-container view) border))(defmethod* set-view-size :after ((view expand-container-mixin) h &optional v)  (declare (ignore h v))  (expand-to-fit (view-container view) border))(defmethod* set-view-container :after ((view expand-container-mixin) container)  (expand-to-fit container border));;; for any view, expand to contain subviews;; Returns t if there's a change; +++ replace view-adjust-for-subviews in mcl-hacks(defmethod expand-to-fit ((view view) border)  (let* ((subviews (coerce (view-subviews view) 'list))         (new-size (point-max (add-points (bounding-size subviews)                                          (make-point border border))                              (view-size view))))    (unless (= new-size (view-size view))      (set-view-size view new-size)      (invalidate-view view)            ; this shouldn't be necessary, but it is      t)    ))(defun bounding-size (subviews)  (make-point (or (maximize subviews                             :key #'(lambda (sv) (+& (point-h (view-size sv))                                                    (point-h (view-position sv))))                            :return-max t)                  0)              (or (maximize subviews                             :key #'(lambda (sv) (+& (point-v (view-size sv))                                                    (point-v (view-position sv))))                            :return-max t)                  0)));;; expanding sheets during a drag causes problems, so do it at listener level;;; actually it isn't working, but it isn't crashing either(defmethod expand-to-fit ((v ccl::sheet-view) border)  (if (zerop border)                    ; kludge and kludge again!    (at-listener-level                    ; I can't believe this works!      (call-next-method))    (expand-to-fit v 0)))(defmethod expand-to-fit ((view null) border)  (declare (ignore border)));;; drag-and-drop;;; shadowing;;; +++ this sort of shadow only works for opaque rectangles. It would be better to generate the;;; shadow from the actual view.  ;;; see new translucent-mixin;;; make grayness a parameter(defclass* shadow-view (ccl::a-view) ())          ; this only really makes sense for a-views(defmethod* view-draw-contents ((v shadow-view))  (with-fore-color (make-gray 30)    (let ((old-mode (rref wptr :grafport.pnMode)))      (#_PenMode #$subPin)      (with-rgb (black *black-color*)        (#_OpColor black))      (#_PaintRect (ccl::rect 0 view-size))      (#_PenMode old-mode))));;; we only need one for now(defparameter *shadow-view* nil)(defparameter *shadow-offset* #@(10 10))(defmethod shadow-view ((shadow-view null) (v simple-view))  (unless *shadow-view*    (setf *shadow-view* (make-instance 'shadow-view)))  (shadow-view *shadow-view* v));[106] minimize calls to set-view-level, it's expensive(defmethod shadow-view ((shadow shadow-view) (v simple-view))  (let ((view-level (view-level v)))    ; Keep original view at same level (typically 0)    (unless (eq (view-container shadow) (view-container v))      (set-view-container shadow (view-container v))      (set-view-level v view-level))    (unless (= (view-level shadow) (1+ view-level))      (set-view-level shadow (1+ view-level)))    (set-view-size shadow (view-size v))    (set-view-position shadow (add-points (view-position v) *shadow-offset*))))(defmethod unshadow-view ((shadow shadow-view))  (set-view-container shadow nil))(defmethod unshadow-view ((shadow null))  )(defclass* drag-and-drop-mixin (view)   ())(defmethod drag-and-drop ((v drag-and-drop-mixin) &optional (where #@(0 0)))  (raise v)  (with-cursor *dragging-cursor*    (warp-mouse (subtract-points (raw-mouse) *shadow-offset*))    (with-mouse-dragging (mouse-pos v)      (set-view-position v (point-max (subtract-points mouse-pos where) #@(0 0)))            ; max might want to be argument      (shadow-view *shadow-view* v)      (highlight-view (drop-target v))))  (unshadow-view *shadow-view*)  (highlight-view nil)  (set-view-position v (add-points (view-position v) *shadow-offset*))  (warp-mouse (add-points (raw-mouse) *shadow-offset*))  (drop v));;; Support functions; raise(defmethod raise ((view drag-and-drop-mixin))  (reseat-view view (dnd-container view)))(defmethod dnd-container ((view drag-and-drop-mixin))  (view-window view))(defmethod dnd-container ((view ccl::a-view))   ; whoops, class-ordering trickery  (aref (view-subviews (view-window view)) 0))      ; this assumes that its contained in a sheet-window, etc.(defmethod reseat-view ((view drag-and-drop-mixin) new-home)  (let ((screen-position (view-position-relative view nil))        (container-position (view-position-relative new-home nil)))    (set-view-container view nil)    (set-view-position view (subtract-points screen-position container-position))    (set-view-container view new-home)))#| old version(defmethod drop-target ((dragged-view drag-and-drop-mixin))  (let ((target? (aif (top-view-under-point                        nil                       (view-mouse-position nil)                       dragged-view                       'highlight-target-mixin)                      (view-superior-of-type it 'drag-mixin))))    (if (can-drop? dragged-view target?)      target? nil)))|#; 3/30/97 23:00 new version, much better(defmethod drop-target ((dragged-view drag-and-drop-mixin))  (drop-target-1 dragged-view (view-container dragged-view)))(defmethod drop-target-1 ((dragged-view drag-and-drop-mixin) within)  (dosequence (sv (view-subviews within) nil)    (when (and (not (eq sv dragged-view))               (cousin-views-overlap? sv dragged-view (view-container dragged-view)))      (if (can-drop? dragged-view sv)        (return sv)        (awhen (drop-target-1 dragged-view sv)          (return it))))));;; from views-overlap? (defun cousin-views-overlap? (v1 v2 common-ancestor)  (let ((p1 (view-position-relative v1 common-ancestor))        (p2 (view-position-relative v2 common-ancestor)))    (with-rect (r1 p1 (add-points p1 (view-size v1)))      (with-rect (r2 p2 (add-points p2 (view-size v2)))        (#_SectRect r1 r2 r2)))))(defmethod can-drop? ((dragged t) (target t))  nil);;; highlight-target;;; +++ not done -- this doesn't work at all for sheet views;;; +++ I suppose that there should be a mixin for targetable items.(defclass* highlight-mixin (view)   ((highlighted? :initform nil)))(defmethod* view-draw-contents :after ((view highlight-mixin))  (when highlighted?    (draw-highlight view)));;; default, can be overridden(defmethod draw-highlight ((view highlight-mixin))  (with-rect (r 0 (view-size view))    (#_FrameRect r)    (#_MoveTo 0 0) (#_LineTo (point-h (view-size view)) (point-v (view-size view)) )))(defmethod* highlight-view ((view highlight-mixin))  (setf highlighted? t)  (invalidate-view view))(defmethod* unhighlight-view ((view highlight-mixin))  (setf highlighted? nil)  (invalidate-view view));;; target -- enforces single highlighting (defclass* highlight-target-mixin (highlight-mixin)   ())(defvar *target* nil)                   ; I guess this could be a class slot!  Oh well(defmethod highlight-view :before ((view highlight-target-mixin))  (unless (eq *target* view)    (unhighlight-view *target*)    (setf *target* view)))(defmethod highlight-view ((view null))  (when *target*    (unhighlight-view *target*)    (setf *target* nil)))                             (defmethod unhighlight-view ((view null))  );;; based on LiveWorld (but improved); I believe all obsolete now#|(defmethod top-view-under-point ((view view) where &optional exclude class)  (flet ((view-suitable? (v)           (and (or (not exclude)                    (not (eq exclude v)))                (or (not class)                    (typep v class)))))    (if (zerop (length (view-subviews view)))      (and (view-suitable? view) view)      (do* ((subviews (view-subviews view))            (i (1- (the fixnum (length subviews))) (1- i))            subview)           ((minusp i) (and (view-suitable? view) view))        (declare (fixnum i))        (setq subview (aref subviews i))        (let ((result (and (or (not exclude)    ; don't test class here, so containers don't have to be of the target class                               (not (eq exclude subview)))                           (view-contains-point-p subview where)                           (top-view-under-point subview (convert-coordinates where view subview) exclude class))))          (if result (return result)))))))(defmethod top-view-under-point ((view simple-view) where &optional exclude class)  (declare (ignore where))  (and (not (eq exclude view))       (typep view class)       view))  (defmethod top-view-under-point ((view null) where &optional exclude class)  (let ((window (window-under-point where)))    (if window      (top-view-under-point window (subtract-points where (view-position window)) exclude class))))(defmethod view-superior-of-type ((v view) type &optional predicate)    ;[50]  (if (and (typep v type)            (or (null predicate)               (funcall predicate v)))    v    (if (view-container v)      (view-superior-of-type (view-container v) type predicate)      nil)))|#; drop(defmethod drop ((v drag-and-drop-mixin))  (let ((target (drop-target v)))    (when target      (reseat-view v target))));;; Switchable translucency.  Doesn't quite look right...;;; +++ borders don't come out right for some reason;;; +++ doesn't affect Text, #_TextMode does not appear to work with blend;;; I suppose the right thing is to write into an auxiliary gworld(defclass* translucent-mixin (simple-view)  ((translucent? :initform nil :accessor translucent?)))(defparameter *translucent-blend-fraction* .3)(defmethod* view-draw-contents :around ((v translucent-mixin))  (if translucent?    (progn      (with-rgb (blend (make-gray (round (* 255 *translucent-blend-fraction*))))          ; Ah, at last, here's how to do it right!        (#_OpColor blend))      (#_PenMode #$blend)      (call-next-method)      (#_PenMode #$patCopy))            ; always leaves patcopy mode, could use (rref wptr :grafport.pnMode)    (call-next-method)))(defmethod* drag-and-drop :around ((v translucent-mixin) &optional ignore)  (setf translucent? t)  (call-next-method)  (setf translucent? nil));;; utitlities(defmethod view-width ((v simple-view))  (point-h (view-size v)))(defmethod view-height ((v simple-view))  (point-v (view-size v)))(defun find-view (start predicate)  (labels ((find-view-1 (view)             (if (funcall predicate view)               (return-from find-view view)               (dosequence (sv (view-subviews view))                 (find-view-1 sv)))))    (find-view-1 start)))(defun find-views (start predicate &aux result)  (labels ((find-view-1 (view)             (if (funcall predicate view)               (push view result))             (dosequence (sv (view-subviews view))               (find-view-1 sv))))    (find-view-1 start)    result))