(in-package :beh)#| ######################################################################The block paletteCopyright © 1996-7 Michael Travers Part of the Behave! systemSend questions, comments, and fixes to mt@media.mit.edu.To Do:- add scrolling buttons and other details  partially done, needs better graphics and stops Way to control order of types and blocks within types.  Common ones should be on left.Way to get overview of the whole thing?  Way to easily see all the types (ie, pick from a popup menu).###################################################################### |#;;; the collection of blocks itself(defclass* palette-view (proto-block beveled-rect-view-mixin gesture-handling-mixin)         ; +++ gesture is temp  ((rows))  (:default-initargs :color (make-gray 60)));;; building this on arg block is a bit of a crock.(defclass* palette-type-label (arg-block)   ((type :initarg :type)))(defmethod can-drop? ((block a-block) (target palette-type-label))  nil)(defmethod* click ((v palette-type-label) where)  (declare (ignore where))  (scroll-to-type (view-container v) type))(defclass* block-scroller (proto-block) ())(defun new-species-dialog ()            ; +++ not there yet  (beep));;; override expansion(defmethod expand-to-fit ((view palette-view) border)  (declare (ignore border)))(defmethod view-draw-contents :after ((view palette-view))  (with-rect (r (view-scroll-position view)                (add-points (view-scroll-position view)                            (view-size view)))    (with-rgb (c *black-color*)      (#_rgbForeColor c)      (#_FrameRect r)    )))(defparameter *palette-height* 54)      ; height of one row, set by generate-palette(defparameter *palette-spacing* 4)(defun generate-palette ()  (let* ((palette (make-instance 'palette-view                    :view-size (make-point 500 *palette-height*)                    :view-position #@(0 0)                    :view-container *win*))         (scroller (make-instance 'block-scroller                     :view-container palette                     :view-position #@(0 26)                     :view-size (make-point 500 *palette-height*)))         (*default-block-font* `("Tekton" 16 :bold))         (*standard-border* 3)#|         (labels (mapcar #'(lambda (type)                             (make-instance 'palette-type-label                               :text (sym-string type)                               :type type                               :text-color (or (get type :color) *gray-color*)                               :view-container palette))                         *all-types*))|#         (labels (mapcar #'(lambda (type)                             (make-instance 'palette-type-label                               :arg (list type type)                               :type type                               :color (type-color type)                               :bevel-border 3                               :view-container palette))                         *all-types*))         (block-rows (mapcar #'(lambda (type)                                 (mapcar #'(lambda (form)                                             (generate-block form                                                             :view-container scroller                                                             :mode :palette))                                         (filter-out #'hidden (get type :xtranslations))))                             *all-types*))         (max-height (maximize (apply #'append block-rows)                               :key #'(lambda (view) (view-height view))                               :return-max t))         row x y         (palette-width 0))        ;;; position labels    (do ((rest labels (cdr rest))         (x 5 (+ x 10 (point-h (view-size (car rest))))))        ((null rest))      (set-view-position (car rest) (make-point x 4)))        (setf *palette-height* (+ max-height *palette-spacing* (view-height (car labels))))        (setf row 0)    (dolist (block-row block-rows)      (setf x 5)      (setf y (* row *palette-height*))      (dolist (block block-row)        (set-view-position block (make-point x                                              (+ y (round (- max-height (view-height block)) 2))))        (incf x (+ (view-width block)                   *palette-spacing*))        (setf palette-width (max palette-width x)))      (incf row))    (set-view-size palette palette-width *palette-height*)         ;;; trash can     (make-instance 'trash-can       :view-container *win*       :view-position (make-point (+ palette-width 12 5) 12))    palette))(defmethod scroll-to-type ((pal palette-view) type)  (let ((row (position type *all-types*))        (scroller (find-view pal #'(lambda (sv) (typep sv 'block-scroller)))))    (if row      (progn; I don't like this, but some people do;        (setf (color pal) (color+lightness (type-color type) -.1));        (invalidate-view pal)        (set-view-scroll-position scroller 0 (* row *palette-height*)))      (warn "Palette ~A doesn't know about type ~A" pal type))))(defmethod* click ((block arg-block) where)  (declare (ignore where))  (let ((type (cadr arg))        (palette (find-view (view-window block) #'(lambda (v) (typep v 'palette-view)))))    (unless (view-contained-by? block palette)      (scroll-to-type palette type))))(defmethod view-cursor ((block arg-block) ignore)  *arrow-cursor*)#|; +++ remove this system of navigation(defmethod click ((v palette-view) where)  (declare (ignore where))  (set-view-scroll-position v 0 (+ (point-v (view-scroll-position v)) *palette-height*) t))(defmethod shift-click ((v palette-view) where)  (declare (ignore where))  (set-view-scroll-position v 0 (- (point-v (view-scroll-position v)) *palette-height*) t ))|#;;; New widgets#|  no longer needed(defclass* scroll-button (layout-block ccl::momentary-pict-button gesture-handling-mixin proto-block)  ((direction :initarg :direction)))(defmethod* ccl::press ((b scroll-button))  (call-next-method)  (let* ((pal (find-view (view-window b) #'(lambda (v) (typep v 'palette-view))))         (new-scroll-position (min (max 0 (+ (point-v (view-scroll-position pal))                                             (* direction *palette-height*)))                                   (* (- (length (slot-value pal 'rows)) 1) *palette-height*))))    (set-view-scroll-position pal 0 new-scroll-position t)))|#;;; trash can;;; not really a button, it's just the easiest way to get a pict up there(defclass* trash-can (highlight-target-mixin ccl::pict-button proto-block)  ()  (:default-initargs    :pict (get-resource :pict 216)          :pict-pressed (get-resource :pict 216)))  (defmethod can-drop? ((block form-block) (target trash-can))  t)(defmethod drop-in ((block form-block) (target trash-can))  ; +++ play a suitable sound  (delete-block block))(defmethod* click-handler ((v form-block) where)  (if (eq mode :palette)    #'(lambda (v ignore) (clone-drag-and-drop v where))         ; +++ where should be scaled, actually    (call-next-method)))   ;;; this is cute but much too slow.  I suppose it is drawing too much.;;; actually, it doesn't seem to be drawing any more views than it has to;;; also, the frame interferes (easily fixed)(defmethod animated-scroll ((v palette-view) amt dy)  (do ((goal (+ amt (point-v (view-scroll-position v))))       (y (point-v (view-scroll-position v)) (+ y dy)))      ((>= y goal))                     ; +++ wrong for scroll back    (set-view-scroll-position v 0 y t)    (window-update-event-handler (view-window v))));;; not really palette, but moving towards real command set.(defmethod click ((block form-block) where)  (at-listener-level    (drag-and-drop block where)));;; Delete blocks by dragging them back to palette(defmethod can-drop? ((dragged form-block) (target palette-view))  t)(defmethod highlight-view ((v palette-view))  )(defmethod drop-in ((block form-block) (target palette-view))  ; +++ play a suitable sound  (delete-block block)); +++ might need to do more for agent blocks(defmethod delete-block ((block form-block))  (set-view-container block nil))