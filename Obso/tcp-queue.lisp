;;; Let a process manag the TCP connection;;; queue elements are (<exp> <continuation>), where <cont> is nil or a procedure to be ;;; called with a value.(defvar *tcp-queue* nil)(defun vft-command (command &optional cont)  (without-interrupts   (if (or cont (null *tcp-queue*))     (push (list command cont) *tcp-queue*)     ; if a response is expected, move to front of queue     (rplacd (last *tcp-queue*)             (list (list command cont))))))(defun remove-vft-commands (filter-proc)  (without-interrupts   (setf *tcp-queue*          (filter-out filter-proc *tcp-queue*))))(defun manage-tcp-connection ()  (do (elem response) (())    (report-and-ignore-errors     (process-wait "TCP Manager" #'(lambda () *tcp-queue*))     (setf elem (pop *tcp-queue*))       (setf response (vft-out (first elem) (second elem)))     (awhen (second elem)       (funcall it response)))))(u::now-and-on-startup (tcp-manager)  (process-run-function "TCP/VFT manager" #'manage-tcp-connection));;; redo existing functions(defmethod* initialize-instance :after ((s vft-species) &rest ignore)  (vft-command 'NewBehavior #'(lambda (result)                                (setf token result))))(defmethod* initialize-instance :after ((b vft-slider-block) &rest ignore)  (vft-command 'NewScalar                #'(lambda (result)                   (setf token result))));;; remove register-variable(defmethod* value-changed :after ((b vft-slider-block))  (let ((new-v (slider-value slider-view)))    (remove-vft-commands #'(lambda (command)                             (and (eq (first command) 'SetScalar)                                  (eq (second command) token))))    (vft-command `(SetScalar ,token ,new-v))))