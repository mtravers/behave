(in-package :beh); Status: works but causes crashes, maybe when sheet resizes.; doesn't know about borders.;;;; +++ most of this is no longer used.(defmethod* view-aspect-ratio ((v view))  (/ (point-v view-size) (point-h view-size)))(defmacro delay-views (&body body) `(progn ,@body))(defmethod cleanup-all ((box view))  (delay-views    (dosequence (v (view-subviews box))      (cleanup-all v)))  (cleanup box))(defmethod cleanup ((box view))  (delay-views     (dosequence (v (view-subviews box))      (when (blockp v)                          (when (view-overlaps? v)          (find-position v))))))(defun blockp (x) (typep x 'basic-block))(defmethod* find-position ((box view))  (let ((pos (view-find-vacant-position view-container box 8)))      ; +++ not quite the right thing    (if (zerop pos)      ;; no room, extend container vertically (+++ this is lame algorithm)      (if (> (view-aspect-ratio (view-container box)) 1.75)        ;; extend horizontally        (setf pos              (view-find-vacant-position               view-container box 8               (add-points (view-size view-container) (make-point (point-h (view-size box)) 0))))        ;; extend vertically        (setf pos (view-find-vacant-position                   view-container box 8                   (add-points (add-points (view-size view-container) (top-usable-box-position))                               (make-point 0 (point-v (view-size box))))))))    (set-view-position box pos)))(defun top-usable-box-position ()  #@(5 5))                              ; +++!(defvar *temp-rgn*)(defvar *temp-rgn2*)(u::now-and-on-startup (make-temp-rgns)  (setf *temp-rgn* (#_NewRgn))  (setf *temp-rgn2* (#_NewRgn)))(defmethod view-find-vacant-position ((view view) subview &optional (border 1) (w-size (view-size view)))  (let* ((size (view-size subview))         (height (point-v size))         (width (point-h size))         (w-height (point-v w-size))         (w-width (point-h w-size))         (rect-rgn *temp-rgn*)         (vacant-rgn *temp-rgn2*)         (top-pos (top-usable-box-position))         (v-list (list (point-v top-pos)))         (h-list (list (point-h top-pos))))    (unwind-protect      (progn        (rlet ((s-rect :rect :topleft (top-usable-box-position) :bottomright w-size))          (#_RectRgn vacant-rgn s-rect)          (dovector (item (view-subviews view))            (let ((position (view-position item))                  (size (view-size item)))              (unless (or (eq item subview) (not position))                (unless size                  (setq size (view-default-size item)))                (let ((lower-right (add-points position size)))                  (rset s-rect :rect.topleft position)                  (rset s-rect :rect.bottomright lower-right))                (#_InsetRect s-rect (- border) (- border))                (#_RectRgn rect-rgn s-rect)                (#_DiffRgn vacant-rgn rect-rgn vacant-rgn)                (pushnew (+ 1 (rref s-rect :rect.right)) h-list)                (pushnew (+ 1 (rref s-rect :rect.bottom)) v-list))))          (setq v-list (sort v-list #'<)                h-list (sort h-list #'<))          (dolist (v v-list)            (dolist (h h-list)              (#_SetRectRgn rect-rgn h v (+ h width) (+ v height))              (#_UnionRgn  vacant-rgn rect-rgn rect-rgn)              (when (and (#_EqualRgn rect-rgn vacant-rgn)                         (< (+ v height) w-height)                         (< (+ h width) w-width))               (return-from view-find-vacant-position (make-point h v))))))        (return-from view-find-vacant-position #@(0 0)))))); (cleanup-all *win*)