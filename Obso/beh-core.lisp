; behavior language -> Starlogo internal lisp format(in-package :beh);;; Argh(defun make-*logo-symbol (sym)  (awhen (find-symbol (symbol-name sym) "U")    (unintern it "U"))  (import sym "U")  (export sym "U"))(defun reset-species ()  (remove-all-instances (class-prototype (find-class 'species))));;; General classes(defclass species (track-named-instances-mixin)  ((slots :accessor species-slots :initform nil :initarg :slots)   (agents :initform (make-hash-table :test #'eq))))(defmethod* initialize-instance :after ((species species) &rest ignore)  (make-*logo-symbol name-of))(defclass agent (named-instance-mixin)  ((species :initarg :species)   (body :initarg :body)))(defmethod* initialize-instance :after ((agent agent) &rest ignore)  (make-*logo-symbol name-of)  (add-agent species agent))(defmethod* add-agent ((species species) agent)  (setf (gethash (name-of agent) agents) agent))(defmethod* species-agents ((species species))  (let ((result nil))    (maphash #'(lambda (ignore agent)                 (push agent result))             agents)    result));;; Starlogo specific(defclass sl-species (species)  (appearance))(defclass sl-agent (agent)  ((lisp-code :accessor agent-lisp-code)   (compiled-ok? :accessor compiled-ok?)))                     ; yucky mechanism;;; assign variables;;; transform body to nested ifelse(defparameter *species-class* 'sl-species)(defparameter *agent-class* 'sl-agent)(defmacro defspecies (species &body parameters)  `(setf ,species         (apply #'make-instance                *species-class*                :name-of ',species                ',parameters)))(defmacro defagent ((name species) &body body)  `(let ((agent (make-instance                  *agent-class*                  :name-of ',name                  :species (find-named-instance-of 'species ',species)                  :body ',body)))     (compile-agent agent)     agent))     (defvar *species*)                      ; bound to objects of current compilation(defvar *agent*)(defmethod* compile-agent ((agent sl-agent))  (let ((*agent* agent)        (*species* species))    (setf compiled-ok? t)               ; default to t    (setf lisp-code          `((if (= (u::breed) ,(name-of species))   ; ask-species              (%list%               ,(compile-agent-body body)))))));;; Guts of compiler(defun compile-agent-body (body)  (if (null body)    nil    (let* ((clause (car body))           (condition (car clause))           (action (cdr clause)))      `(ifelse ,(parse-type 'condition condition)               (%list% ,@(mapcar #'(lambda (cmd)                                      (parse-type 'action cmd))                                 action))               (%list% ,@(compile-agent-body (cdr body)))))));;; here, let's be properly data-driven(defmacro define-syntax (type form &body body)  `(define-syntax-1 ',type ',form ',body))(defun define-syntax-1 (type form body)  (awhen (if (atom form)           (find form (get type :translations) :key #'car)           (find (car form)                 (get type :translations) :key #'caar))    (deletef it (get type :translations)))  (push (list form body)        (get type :translations))  (list 'quote form))(defun parse-type (type thing)  ;; handle special cases  (case type    (number (when (numberp thing)              (return-from parse-type thing))))  (dolist (translation (get type :translations)                       ; +++ should be done as handler                       (progn                         (warn "In (~A ~A), can't parse ~a as ~a" (name-of *agent*) (name-of *species*) thing type)                         (setf (compiled-ok? *agent*) nil)                         nil))    (cond ((and (symbolp thing) (eq thing (car translation)))           (return (eval (car (cadr translation)))))          ((and (listp thing) (listp (car translation))                (eq (car thing)                    (car (car translation))))           (unless (= (length thing) (length (car translation)))             (warn "In (~A ~A), wrong number of arguments in ~A" (name-of *agent*) (name-of *species*) thing)             (setf (compiled-ok? *agent*) nil))           (progv (mapcar #'(lambda (term) (if (listp term) (car term) term))                          (cdr (car translation)))                  (cdr thing)             (return (eval (car (cadr translation))))))          (t nil))))(define-syntax condition (always)  'true)(define-syntax condition (near specifier (range number))        ; specifier == (specifier specifier)  `(u::near ,(parse-type 'specifier specifier) ,range))(define-syntax condition (on specifier)  `(u::on ,(parse-type 'specifier specifier)))(define-syntax condition (pick specifier)  `(pick ,(parse-type 'specifier specifier)))(define-syntax specifier (a breed)  (sl-symbol breed))(defun sl-symbol (symbol)  (intern (symbol-name symbol) :u));;; actions are lists of forms(define-syntax action (go direction amount)  `(go ,(parse-type 'direction direction)        ,(parse-type 'number amount)));;; scale these by /10 (define-syntax action (turn amount)  `(rt ,(parse-type 'number amount)))(define-syntax action (fd amount)  `(fd ,(parse-type 'number amount)))(define-syntax action (eat thing)  `(u::eat ,(parse-type 'thing thing)))(define-syntax direction (randomly)  '(random 360))                        ; do we need to scale number?  (define-syntax direction (towards thing)  `(towards-thing ,(parse-type 'thing thing)))(define-syntax direction (away-from thing)  `(away-from-thing ,(parse-type 'thing thing)))(define-syntax thing (it)  (turtle-var 'it))(defun turtle-var (name)  `(u::.thing ,(+ 1 (position name *built-in-variables*))))(define-syntax thing (a-random species)  `(U::%one-of-random-breeds ,(parse-type 'specifier species))) ;;; some constant headings(define-syntax direction (east)  90)(define-syntax number (random number)  `(frandom ,(parse-type 'number number)))(define-syntax number (arand number)  `(arandf ,(parse-type 'number number)))#|Maybe I'm going about this in completely the wrong way.Using %LIST% in general won't work -- it's not PROGN, and thereis no equivalent to PROGN as far as I can tell. So the thing to do isdefine all those things as starlogo functions.|#                          