(in-package :beh)#|outstanding problems:- switch in agent block- number constants- tabbing, etc.- see +++|##|;;; Form layout specification(defform (> condition) ((a number) (b number))  `(> ,a ,b) ((a :> b))  <--- this is layout;;; two rows, make sure holes are aligned((:go (:tab direction)) (:by (:tab amount)))((:when ((:tab 20) condition))  <--- leave a specific amount of space, for widgeth (:then ((:tab 20) action)))((((:t):when ((:tab 20) condition))  <--- leave a specific amount of space, for widgeth (:then ((:tab 20) action))) ((a :< b))                      <--- constant word in the middlegetting uglyblock-spec:= keyword, nonkeyword, or list  keywords are noise text  nonkeywords are arguments  lists are(block-spec [options]*), ie (when :rtab 30))line-spec = list of block-specswhole-spec = list of line-specs|#; +++ doesn't handle keywords for tabbing yet.; +++ won't work at all when holes are filled in, arg! (so to speak)(defparameter *spacing* 10)             ; +++ this spacing technique is too crude for good layout;;; assumes subblocks are all sized correctly(defmethod layout-block ((block form-block) &optional (layout-spec (get-layout (form block))))  (let ((y *spacing*))    (dolist (row layout-spec)      (setf y (+ *spacing* (layout-row block row y)))))  (shrink-wrap block *spacing*));;; do nothing for sliders, for now(defmethod layout-block ((block slider-block) &optional (layout-spec (get-layout (form block))))  )#|; +++ doesn't monitor distinction between text/form blocks(defmethod find-block-from-spec ((container form-block) spec)  (let* ((name (if (listp spec) (car spec) spec))         (string-name (string name))         (text-block? (keywordp name)))    (dosequence (sv (view-subviews container)                    (error "no block named ~A in ~A" name container))      (when (string-equal (block-name sv) string-name)        (return sv)))))(defmethod* block-name ((v text-view))  text)(defmethod* block-name ((v hole))  text);;; i'm sorry, this is ludicrous...(defmethod block-name ((v form-block))  (let ((hole (cdr (assq v (slot-value (view-container v) 'saved-holes)))))    (block-name hole)))(defmethod block-name ((v simple-view))  nil)|#;;; new better way to do this(defmethod find-block-from-spec ((container form-block) spec)  (let* ((name (keyword (if (listp spec) (car spec) spec))))    (dosequence (sv (view-subviews container)                    (error "no block named ~A in ~A" name container))      (when (and (typep sv 'layout-block)                 (eq (tag sv) name))        (return sv)))));;; tag management(defmethod* create-subviews ((block form-block))  (dolist (arg (args form))    (make-instance 'arg-block      :view-container block      :arg arg      :tag (keyword (car arg))      :view-font (view-font block)      :text (sym-string (car arg))      :color (type-color (cadr arg))))  (dolist (row (get-layout form))    (dolist (item row)      (let ((name (if (listp item) (car item) item)))        (when (keywordp name)          (make-instance 'block-text-subview            :tag name            :text (sym-string name)            :text-color (default-text-color block)            :view-container block            :view-font (view-font block)))))))(defmethod layout-row ((block form-block) row-spec top)  (flet ((find-block (spec)           (find-block-from-spec block spec)))    (let* ((row-views (mapcar #'find-block row-spec))           (row-height (maximize row-views                                 :key #'(lambda (v) (point-v (view-size v)))                                 :return-max t) )           (x *spacing*))      (dolist (block-spec row-spec)        (setf x (+ *spacing* (position-subblock (find-block block-spec) block-spec top x row-height))))      (values (+ top row-height)))))(defmethod position-subblock ((block view) spec top left row-height)  (set-view-position block (make-point left (+ top                                               (round (- row-height (point-v (view-size block)))                                                      2))))  (values (+ left (point-h (view-size block)))))(defmethod layout-block-recursive ((block form-block))  (dosequence (sv (view-subviews block))    (call-if #'layout-block-recursive sv))  (layout-block block)); +++ to utils(defun call-if (gf &rest args)  (when (apply #'method-exists-p gf args)    (apply gf args)))(defmethod shrink-wrap ((v view) border)  (let ((svs (coerce (view-subviews v) 'list)))    (set-view-size      v     (if svs       (add-points (bounding-size (coerce (view-subviews v) 'list))                   (make-point border border))       (view-default-size v)))));;; relayout when block is dropped or raised(defmethod drop :after ((block form-block))  (aif (view-container block)       (relayout it)));;; extends existing method(defmethod raise :around ((block form-block))  (let ((container (view-container block)))    (call-next-method)    (when (typep container 'form-block)      (restore-hole container block)      (relayout container))))           ; extension;;; called when something changes due to drop or raise(defmethod relayout ((block form-block))  (layout-block-recursive block))(defmethod relayout ((view t)) );;; this is better...does a relayout of everything(defmethod relayout ((block form-block))  (if (layout-top? block)    (layout-block-recursive block)    (relayout (view-container block))))(defmethod layout-top? ((block form-block))  (not (typep (view-container block) 'form-block)));;; Connect to forms(defclass form ()  ((name :initarg :name :reader name )   (type :initarg :type :reader type)   (args :initarg :args :reader args)   (block-class :initarg :block-class :reader block-class)   (body :initarg :body :reader body)   (layout :initarg :layout :initform nil)))(defmethod* get-layout ((form form))  (or layout      (cond ((numberp name)             nil)            (t (list (cons (keyword name) (mapcar #'car args)))))))       ; default(defmacro defform ((name type &key (block-class 'form-block) layout) arglist &body body)  `(defform-1 ',name ',type ',arglist ',body ',block-class ',layout))(defmacro defprim (name type &key (block-class 'form-block))  `(defform-1 ',name ',type nil '(',name) ',block-class))(defun defform-1 (name type args body block-class layout)  (awhen (find name             (get type :xtranslations) :key #'name)    (deletef it (get type :xtranslations)))  (pushnew type *all-types*)  (let ((form (make-instance 'form                :name name                :type type                :args (mapcar #'(lambda (argdef)                                  (if (symbolp argdef)                                    (list argdef argdef)                                    argdef))                              args)                :block-class block-class                :body body                :layout layout)))    (push form (get type :xtranslations))    form))(defform (if agent          :block-class agent-block          :layout ((:if condition)                   (action)))         (condition action)  `(u::if ,condition     (u::%list% ,action)))(defmethod initialize-instance :after ((block form-block) &rest ignore)  (create-subviews block)  (layout-block block))(defmethod* generate-block ((form form) &rest other-args)  (let ((block (apply #'make-instance (block-class form)                 :view-container *win*                 :form form                 :color (type-color type)                 other-args)))    block))