;; ****************************************************************;;;; Author: Alan Ruttenberg, Interval Research;; email:  alanr@media.mit.edu;; fixed by Brian Williams;;;; Created: Wednesday August 23,1995;; ;; ****************************************************************(in-package :ccl)#||Offscreen gworld. Basically like a screen in which you can specify the pixel depth. You canset the current port to be the gworld, do drawing, and then blt the resultto the screen, using copybits.Two modes for the gworldCopy speed:You set the rectangle of the gworld to be the position that you want it to be on the screen, so that copybits works as fast as possible. The coordinate system is topleft 0 0.Image depth:You set the boundsrect to what you want, and pass a pixel depth.||#(export '(view-gdevice-pixmap max-bit-depth view-depth pixels-locked           with-gworld-pixmap with-focused-gworld with-temp-gworld           make-gworld));; ASSUMES USE OF AVOID-TRAP-LOSSAGE HACK TO INSERT REQUIRE-TRAPS(defmethod view-gdevice-pixmap ((v view))  (rlet ((r :rect :topleft (ccl::%local-to-global (wptr v) #@(0 0))            :bottomright (ccl::%local-to-global (wptr v) (view-size v))))    (rref #-powerpc(#_getmaxdevice :ptr r :ptr)          #+powerpc (#_getmaxdevice r)          gdevice.gdpmap)))(defun max-bit-depth ()  (multiple-value-bind (topleft screen-size)                        (ccl::find-best-color-screen)    (rlet ((r :rect :topleft topleft              :bottomright (add-points topleft screen-size)))      (rref (rref (#_getmaxdevice r) :gdevice.gdpmap) :pixmap.pixelsize))))(defmethod view-depth ((v view))  (rref (view-gdevice-pixmap v) :pixmap.pixelsize))(defun pixels-locked (pm)  (logbitp #$pixelslockedbit           (#_getPixelsState pm)))(defmacro with-gworld-pixmap ((gworld pixmap) &body body)  (let ((pm (make-symbol "PIXMAPHANDLE"))        (handle-state (make-symbol "HANDLESTATE"))        (pixels-locked (make-symbol "PIXELS-LOCKED")))    `(let* ((,pm (#_getgworldpixmap ,gworld))            (,handle-state (require-trap #_HGetState ,pm))            (,pixels-locked (pixels-locked ,pm)))       (unwind-protect          (progn           (when (not ,pixels-locked)             (unless (#_lockpixels ,pm)               (error "pixmap no longer valid")))           (unless (logand ,handle-state #x80)             (#_Hlock ,pm))           (let ((,pixmap (%get-ptr ,pm)))             ,pixmap             ,@body))         (require-trap #_HSetState ,pm ,handle-state)         (unless ,pixels-locked           (#_unlockpixels ,pm))))))(defmacro with-focused-gworld ((gworld &optional (pm nil pm-supplied)) &body body)  (let ((p (make-symbol "PORT"))        (g (make-symbol "GDEVICE"))        (pm (or pm (make-symbol "PIXMAP"))))    `(rlet ((,p :pointer) (,g :pointer))       (if ,gworld         (unwind-protect            (without-interrupts             (#_getgworld ,p ,g)            (#_setgworld ,gworld (%null-ptr))            (with-gworld-pixmap (,gworld ,pm) ,@body)            )           (#_setgworld (%get-ptr ,p) (%get-ptr ,g)))         ,(unless pm-supplied            `(progn ,@body))))))(defmacro with-temp-gworld ((width height depth gworld &optional ctable) &body body)  `(with-temp-gworld-1 ,width ,height ,depth ,ctable     #'(lambda(,gworld)         ,@Body)))(defun with-temp-gworld-1 (width height depth ctable continuation)  (assert (member depth '(1 2 4 8 16 32) :test '=) ()          "Depth needs to be a power of two")  (rlet ((it :pointer)         (r :rect :topleft 0 :bottom height :right width))    (#_newgworld  it  depth  r  (if (eq ctable :gray)                                  (#_getctable (case depth                                                 (2 34)                                                 (4 36)                                                 (8 40)))                                  (%null-ptr))     (%null-ptr) 0)    (unwind-protect      (let ((world (%get-ptr it)))        (with-focused-gworld (world pm)          (#_cliprect r)          (#_eraserect r))        (funcall continuation world))      (#_disposegworld (%get-ptr it)))))(defun make-gworld (width height depth ctable)  (assert (member depth '(1 2 4 8 16 32) :test '=) ()          "Depth needs to be a power of two")  (rlet ((it :pointer)         (r :rect :topleft 0 :bottom height :right width))    (let ((result (#_newgworld  it  depth  r  (if (eq ctable :gray)                                                (#_getctable (case depth                                                               (2 34)                                                               (4 36)                                                               (8 40)))                                                (%null-ptr))                   (%null-ptr)  0;(+ #$keepLocal #$pixelsPurgeable)                   )))      (when (minusp result)        (error "Didn't succeed at allocating gworld"))      (let ((world (%get-ptr it)))        (with-focused-gworld (world pm)          (#_cliprect r)          (#_eraserect r))        world))))#|(defun test-gworld (&optional dither?)  (let ((w (make-instance 'window :color-p t :view-size #@(500 200))))    (with-temp-gworld (500 200 32 gw)       (with-focused-gworld (gw)        (loop for i below 10 do              (rlet ((rgb :rgbcolor :red (random 65535) :blue (random 65535) :green (random 65535)))                (#_rgbforecolor rgb)                (rlet ((r :rect :top 0 :left (* i 50) :right (+ 50 (* i 50)) :bottom 200))                  (#_paintrect r)))))      (rlet ((r :rect :topleft 0 :bottomright #@(500 200)))        (with-focused-view w          (with-gworld-pixmap (gw gwpm)            (#_copybits gwpm (rref (wptr w) windowrecord.portbits) r r (if dither? 64 0) (%null-ptr))))        ))));; a scale of 3 gives good results. In some cases a scale of 2 is enough(defun antialiastest (scale fontsize string                             &optional                            (width (string-width string `("times" ,fontsize)))                            (height (ceiling (* 2.5 fontsize))))  (let ((w (make-instance 'window :color-p t :view-size (make-point width height)                          :grow-icon-p nil)))    (with-temp-gworld ((* scale width) (floor (* scale height) 1.5) 1 gw)      (with-pstrs ((a string)                   (n "times"))        (let ((fnum (%stack-block ((it 4)) (#_getfnum n it) (%get-word it))))          (with-focused-gworld (gw)            (#_textfont fnum)            (#_textsize (floor (* fontsize scale)))            (#_moveto 0 (floor (* 1.1 fontsize scale)))            (#_drawstring a)            )))      (rlet ((r :rect :topleft 0 :bottom (ceiling height 1.1) :right width)             (rs :rect :topleft 0 :bottom (ceiling (* scale height) 1.1) :right (* scale width)))        (with-focused-view w          ;; pixel averaging only seems to work when dithering. I guess that           ;; only direct pixmaps are averaged when changing sizes.          (with-temp-gworld (width (ceiling height 1.1) 4 gwbw :gray)            ;; copy to a 4 bit greyscale world            (with-focused-gworld (gwbw pmbw)              (with-gworld-pixmap (gw pm)                (#_copybits pm pmbw rs r 64 (%null-ptr))))            ;; and write this to the screen (or use as a deepmask, for instance)            (with-focused-view w              (with-gworld-pixmap (gwbw pmbw)                (#_copybits pmbw (rref (wptr w) windowrecord.portbits) r r 0 (%null-ptr)))              ))          (set-view-font w (list "times" fontsize ))          (#_moveto 0 (floor (* fontsize 2.2)))          (write-string string w))))));; seem to fail when I try to shrink and dither into a deeper world (%stack-block ((it 4))            (%put-ptr it gw)            ;(print (#_updategworld it 4 r (%null-ptr)  (%null-ptr)            (logior 4 (ash 2 29)))||#(provide 'offscreen)