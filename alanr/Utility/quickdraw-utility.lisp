;;****************************************************************;; ;; Author: Alan Ruttenberg, MIT Media Lab ;; email:  alanr@media.mit.edu;;;; Thursday April 20,1995 made with-fore-color work;; Created: Wednesday May 22,1991 0:39am;; ;;****************************************************************(in-package :ccl);; ****************************************************************#+processes(progn  (defglobal *spare-str255* (#_newptr 256))  (defglobal *spare-rect-1* (#_newptr 8))  (defglobal *spare-rect-2* (#_newptr 8))  (defglobal *spare-rgb* (#_newptr 6))  (defglobal *spare-time* (make-record :timerecord))  (defglobal *spare-time-2* (make-record :timerecord))  (defglobal *spare-time-3* (make-record :timerecord)))#-processes(progn  (defvar *spare-str255* (#_newptr 256))  (defvar *spare-rect-1*(#_newptr 8))  (defvar *spare-rect-2*(#_newptr 8))  (defvar *spare-rgb* (#_newptr 6))  (defvar *spare-time* (make-record :timerecord))  (defvar *spare-time-2* (make-record :timerecord))  (defvar *spare-time-3* (make-record :timerecord)))(def-load-pointers spare-rectangle ()  (setq *spare-rect-1* (#_newptr 8))  (setq *spare-rect-2* (#_newptr 8))  (setq *spare-str255* (#_newptr 256))  (setq *spare-rgb* (#_newptr 6))  (setq *spare-time* (make-record :timerecord))  (setq *spare-time-2* (make-record :timerecord))  (setq *spare-time-3* (make-record :timerecord)))(defmacro stuffrect (rect size-or-topleft-or-top &optional bottomright-or-left bottom right)  `(progn     (rect-internal ,rect ,size-or-topleft-or-top  ,bottomright-or-left ,bottom ,right)     ,rect))(defun some-ptinrect (rect &rest points)  (declare (dynamic-extent points))  (loop for p in points thereis (#_ptinrect p rect)))(defmacro rect-internal (rect size-or-topleft-or-top &optional bottomright-or-left bottom right)  (if size-or-topleft-or-top    (if (not bottomright-or-left)      `(progn         (setf (rref ,rect :rect.topleft) #@(0 0))         (setf (rref ,rect :rect.bottomright) ,size-or-topleft-or-top)         ,rect)      (if bottom        `(progn           (setf (rref ,rect :rect.top) ,size-or-topleft-or-top)           (setf (rref ,rect :rect.bottom) ,bottom)           (setf (rref ,rect :rect.right) ,right)           (setf (rref ,rect :rect.left) ,bottomright-or-left)           ,rect)        `(progn           (setf (rref ,rect :rect.topleft) ,size-or-topleft-or-top)           (setf (rref ,rect :rect.bottomright) ,bottomright-or-left)           ,rect)))    rect))(defmacro rect (&optional size-or-topleft-or-top bottomright-or-left bottom right)  `(rect-internal *spare-rect-1* ,size-or-topleft-or-top ,bottomright-or-left ,bottom ,right))(defmacro rect2 (&optional size-or-topleft-or-top bottomright-or-left bottom right)  `(rect-internal *spare-rect-2* ,size-or-topleft-or-top ,bottomright-or-left ,bottom ,right))(defmacro pstr (string)  `(progn      (%pstr-pointer ,string *spare-str255*)     *spare-str255*))(defmacro rgb (color)  `(progn      (color-to-rgb ,color *spare-rgb*)     *spare-rgb*))(defmacro with-color-saved ( &body body)  (let ((old-fore (gensym)))    `(rlet ((,old-fore :rgbcolor))       (#_GetForeColor :ptr ,old-fore)       (unwind-protect         (progn ,@body)         (#_rgbForeColor :ptr ,old-fore)))))(defmacro rect-region (size-or-topleft-or-top &optional bottomright-or-left bottom right)  (let ((it (gensym)))    `(let ((,it (require-trap #_newrgn)))       (require-trap #_rectrgn ,it (rect2 ,size-or-topleft-or-top ,bottomright-or-left ,bottom ,right))       ,it)))(defmacro region-rect (region)  `(progn     (setf (rref *spare-rect-1* :rect.topleft) (rref ,region region.rgnbbox.topleft)           (rref *spare-rect-1* :rect.bottomright) (rref ,region :region.rgnbbox.bottomright))     *spare-rect-1*));; not really quickdraw(defun timerecord-to-seconds (&optional (timerecord *spare-time*))  (/ (+ (ash (rref timerecord :timerecord.value.hi) 32)        (rref timerecord :timerecord.value.lo))     (rref timerecord :timerecord.scale)))(defun seconds-to-timerecord (timerecord time)  (let ((time-in-milliseconds (floor (* time 1000))))    (setf (rref timerecord :timerecord.value.hi)          (ash time-in-milliseconds -32))    (setf (rref timerecord :timerecord.value.lo)          (logand time-in-milliseconds #xffffffff))    (setf (rref timerecord :timerecord.scale) 1000)    ;; if you don't initialize base, then you die!    (setf (rref timerecord :timerecord.base) (%null-ptr))    timerecord))(defmacro timerecord (&optional (seconds 0))  `(progn     (seconds-to-timerecord *spare-time* ,seconds)     *spare-time*))(defmacro timerecord2 (&optional (seconds 0))  `(progn     (seconds-to-timerecord *spare-time* ,seconds)     *spare-time-2*))(defmacro timerecord3 (&optional (seconds 0))  `(progn     (seconds-to-timerecord *spare-time* ,seconds)     *spare-time-3*));; ****************************************************************;; A couple of debug print routines.(defun rect-string (r &optional (message ""))  (format nil "~A#<rect ~A ~A>"           message          (point-string (rref r rect.topleft))          (point-string (rref r rect.bottomright))))(defun region-string (r &optional (message ""))  (format nil "~A#<region ~A ~A>"           message          (point-string (rref r region.rgnbbox.topleft))          (point-string (rref r region.rgnbbox.bottomright))));; ****************************************************************;; Some help for drawing the regions. Surround some drawing code with;; drawing region, and the region is returned.(defmacro drawing-region (&rest body)  "Returns a gcable region - i.e. no need to dispose"  `(drawing-region-internal #'(lambda(),@body)))(defun drawing-region-internal (drawer)  (let ((manager-port (window-manager-port))        (returned-region nil))    (with-port manager-port      (let ((region (%new-rgn)))        (unwind-protect           (progn            (#_openrgn)            (funcall drawer)            (#_closergn region)            (setq returned-region region)            (setq region nil))          (when region             (dispose-region region)))))    returned-region))(defvar *empty-region*)(def-load-pointers utility-regions ()  (setq *empty-region* (#_newrgn))  (#_setrectrgn *empty-region* 0 0 0 0));; ****************************************************************;; Some screen dimension accessors.#-ccl-3(defun menubar-height ()  (%get-word (%int-to-ptr #xbaa)))(defun screen-resolution ()  (%get-word (%int-to-ptr 258)));; ****************************************************************(defun window-manager-port ()  (rlet ((it :pointer))    (#_getcwmgrport it)    (%get-ptr it)));; ****************************************************************;; makes a (gcable) polygon which has 'points' as  vertices. (defun make-polygon (&rest points)  (with-port (window-manager-port)    (let* ((poly (make-gcable-macptr $flags_disposhandle)))      (%setf-macptr poly (#_openpoly))      (unwind-protect         (progn          (#_moveto :long (car points))          (loop for p in (rest points)                do (#_lineto :long p)))        (#_closepoly))      poly)))    ;; ****************************************************************;; This came up because of a situation where handles from a gworld are locked;; by with-pointers, and unlocked when done, except that the gworld has been disposed;; by updategworld. And the version of hunlock that is used causes an error because the;; the block is already free. This version does not cause the error.(defmacro with-dereferenced-handle-perhaps-disposed-in-body ((var handle) &body body)  `(progn     (require-trap #_hlock ,handle)     (let ((,var (%get-ptr ,handle)))       (declare (dynamic-extent ,var))       (unwind-protect (progn ,@body)         (require-trap #_hunlock ,handle)))));; ****************************************************************;; view-send-behind, view-layer(defmethod view-send-behind ((v simple-view) sibling)  (let* ((container (view-container v))         (siblings (and container (view-subviews container))))    (when (and container (find sibling siblings) (neq v sibling))      (let ((sib-layer (view-level sibling))            (my-layer (view-level v)))        (without-interrupts         (unless (= my-layer (1+ sib-layer))           (if (= sib-layer (1- (length siblings)))             (set-view-level v sib-layer)             (if (< my-layer sib-layer)               (set-view-level v sib-layer)               (set-view-level v (1+ sib-layer))))))))))                        (defun setf-method (symbol)  (let ((f (list 'setf symbol)))    (declare (dynamic-extent f))    (fdefinition f)))(defmacro @- (&rest points)  (if (null (cdr points))    (car points)    `(@- (subtract-points ,(car points) ,(cadr points)) ,@(cddr points))))(defmacro @+ (&rest points)  (if (null (cdr points))    (car points)    `(@+ (add-points ,(car points) ,(cadr points)) ,@(cddr points))))(defmacro @# (point) ; flip a point  (let ((p (gensym)))  `(let ((,p ,point))     (make-point (@y ,p) (@x ,p)))))     (defmacro @h (point) `(the fixnum (point-h ,point)))(defmacro @x (point) `(the fixnum (point-h ,point)))(defmacro @v (point) `(the fixnum (point-v ,point)))(defmacro @y (point) `(the fixnum (point-v ,point)))(defmacro @$ (point) `(point-string ,point))(defmacro @! (h v) `(make-point ,h ,v));; Monday November 4,1996 oops. Not on a powerpc it doesn't#-powerpc(define-compiler-macro @! (&whole call &environment env h v)  (cond ((eql h 0) (if (nx-inhibit-safety-checking env) `(%ilsl 16 ,v) `(ash ,v 16)))        ((eql v 0) h)        (t          (if (nx-inhibit-safety-checking env)           `(lap-inline (,h ,v)              (getint arg_z)              (getint arg_y)              (swap arg_z)              (move.w arg_y arg_z)              (jsr_subprim $sp-mkpoint))           `(make-point ,h ,v)))))(defmacro @* (scale point)  `(make-point (round (* ,scale (@x ,point))) (round (* ,scale (@y ,point)))));; midpoint(defmacro @1/2 (point1 point2)   `(locally      (make-point (the fixnum (ash (the fixnum (+ (the fixnum (@h ,point1)) (the fixnum (@h ,point2)))) -1))                 (the fixnum (ash (the fixnum (+ (the fixnum (@v ,point1)) (the fixnum (@v ,point2)))) -1)))))