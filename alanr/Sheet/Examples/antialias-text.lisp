(in-package :ccl);; Examples of use of gworld backed views;; mix in and click on a view lets you drag it as you move the mouse.(defclass click-move-drag ()  ())(defmethod view-click-event-handler ((v click-move-drag) where)  (declare (ignore where))  (loop with initialpos = (view-position v)        with initialmouse = (view-mouse-position (view-container v))        for mouse = (view-mouse-position (view-container v))        for pos = (add-points initialpos (subtract-points mouse initialmouse))        do         (set-view-position v pos)        (let ((w (view-window v)))          (and w (window-update-event-handler w)))        until (not (mouse-down-p))));; This view sizes itself to the size of the text in the view font. But;; it draws the text somewhat larger on a temporarily allocated black and white ;; sheet-view, then scales it down using copybits to draw it to the deeper;; screen (8 bits say). This has the effect of antialiasing the text. I think;; that the text looks good only above 24 points. This of course depends on you;; having scalable fonts so that the larger image is in fact more detailed.;; this must be installed in an a-window.(defclass antialiased-static-text-view (click-move-drag a-view)  ((the-text :initform "MCL makes me happy! " :accessor the-text)   ;; Enlargment of 3 (= 9 times area), seems to do a good job   (enlargement :initarg :enlargement :initform 3 :accessor enlargement))  )(defmethod view-draw-contents ((v antialiased-static-text-view))  (when (the-text v)    (let ((font (view-font v)))      ;; sanity      (assert (and (stringp (first font)) (numberp (second font))) ()              "Expected font to have form like '(\"geneva\" 12)")      ;; create the bigger font spec      (let ((bigger-font (list* (car font) (* (second font) (enlargement v))                                (nthcdr 2 font))))        (let ((width (string-width (the-text v) bigger-font)))          (multiple-value-bind (ascent descent) (font-info bigger-font)            ;; allocate a sheet big enough to draw the larger text            (let ((bitsheet                   (make-instance 'sheet-view                      :depth 1                      :view-size  (make-point width (+ ascent descent))                     :view-font bigger-font                    )))              ;; draw the bigger text              (with-focused-view bitsheet                (#_moveto 0 (- (point-v (view-size bitsheet)) descent))                (write-string (the-text v) bitsheet))              ;; now copy and scale to the destination. Not that only ditherpix causes the pixel              ;; averaging necessary to give the antialias effect (unless you are drawing to              ;; a 24 bit screen.              ;; With-pixmap gets you a properly locked pixmap for the instance specified.              (with-pixmap (bitsheet-pix bitsheet)                (with-pixmap (view-pix (view-sheet v))                  (#_copybits bitsheet-pix view-pix                    ;; rect and rect2 are utility functions which set and return a couple of                   ;; preallocated rects                   (rect (view-size bitsheet))                   (rect2 (view-size v))                   #$dithercopy (%null-ptr))))              ;; unnecessary, since the garbage collector will eventually get to it,              ;; but might as well save it work. (and free up the memory sooner)              (dispose bitsheet)               )))))));; adjust the size of the view to the dimensions needed to accomodate the text.(defmethod adjust-view-size ((v antialiased-static-text-view))  (multiple-value-bind (ascent descent) (font-info (view-font v))    (set-view-size v (make-point (string-width (the-text v) (view-font v)) (+ ascent descent) ))))(defmethod initialize-instance  ((v antialiased-static-text-view) &key)  (call-next-method)  (when (the-text v) (adjust-view-size v))  );; when the text is changed, adjust the size of the view and force redraw by invalidating it.(defmethod (setf the-text) :after (new-value (v antialiased-static-text-view))  (declare (ignore new-value))  (when (the-text v)     (adjust-view-size v)    (invalidate-view v t)));; run this, click on the text and drag it.(defun test-antialias ()  (make-instance 'a-window :view-subviews (list (make-instance 'antialiased-static-text-view                                                  :view-font '("Times" 36))))  );; ****************************************************************;; Now an example where the drawn antialiased text is cached in a ;; sheet view, so that updating doesn't take so long. It doesn't take;; so long because the expensive part of the drawing is the drawing of the larger;; text and the copybits scaling. So instead of drawing to the screen, we'll enclose;; that view in another sheet view (this time 8 bits deep). That view will be drawn to once, ;; and thereafter drawing *it* will be much faster.(defclass test-container (click-move-drag sheet-view)  ()  (:default-initargs :depth 8));; make this view size itself to the view it contains.;; I'm not sure where the best place to put this method is.(defmethod view-draw-contents :before ((v test-container) )  (let ((contains (and (view-subviews v) (elt (view-subviews v) 0))))    (when (and contains (not (= (view-size v) (view-size contains))))      (set-view-size v (view-size contains)))    ));; Run and then click on the text and drag it around.(defmethod test-antialias-backed ()  (make-instance 'a-window     :view-subviews   (list (make-instance 'test-container            :view-subviews           (list (make-instance 'antialiased-static-text-view                   :view-font '("Times" 36)))))));; ****************************************************************;; In the last example dragging the text around was faster, but there was flicker. This;; is because each time the view moved it was first invalidated, and erased, then redrawn.;; We can make that alot cleaner by having the erasing and redrawing happen on yet another ;; and then copying *that* to the screen - effectively double buffered animation.;; To do this we make another sheet-view which encloses the previously defined view.;; For simplicity I haven't bothered to have its size changed as the window changes size.;; run and then click and drag text. Not substantially smoother animation.(defun test-antialias-behind-window-sheet ()  (make-instance 'a-window     :view-size #@(400 300)    :view-subviews    (list (make-instance 'sheet-view :depth 8 :view-size #@(400 300)                         :view-subviews                         (list (make-instance 'test-container                                  :view-subviews                                 (list (make-instance 'antialiased-static-text-view                                         :view-font '("Times" 36)))))))))  