© Copyright Apple Computer 1991-1992Alan Ruttenbergalanr@media.mit.eduWritten to support work in the Apple Human Interface Group.The files in this set implement several new view classes with capabilitiesprovided from the mac toolbox. The principle classes are sheet-view,shaped-view, and quickdraw-bottleneck-mixin. In addition, there are severalfiles of example code which uses these utilities. Sheet-views are views which have an offscreen bitmap onto which subviews ofthem draw. Sheet-views can be used to create a variety of special drawingeffects, to cache complex drawings, and to create smooth animation.Shaped-views are which which can have a shape which is defined by a region.Shaped-views are useful to create windows which are not necessarily square.Quickdraw-bottleneck-mixin allows you to write lisp methods on the low levelquickdraw-procedures (the qdprocs). For instance you could write an aroundmethod for #_framerect.A variety of other classes are defined which are components of these two, or arebuilt on them. These include the classes gworld, has-pixmap, has-colortable,pixmap, cicon, shaped-window, shrink-wrapped-view, shrink-wrapped-window,floating-shaped-window, floating-shrink-wrapped-window, a-view, a-base,a-window, sheet-view, sheet-base, drag-content-mixin.In this file I'll describe each of these classes, their implementation, and howto use them. Search for "******" for section beginnings. Code examples in this file maydepend on ones earlier in the file.****************************************************************LoadingThis set of files are loaded with the load-if-newer function in load-newer.lisp.sheet-file-set.lisp describes the order of loading. Note that files in the setutility-file-set are depended on and need to be loaded first (which happensautomatically with load-newer).****************************************************************a-window, a-viewThese are the base classes for windows and views which want to access thesecapabilities. These classes are built on views but have necessary extra hooks.Any window which has an a-view must be an a-window. All views inside a-windowsmust be a-views. Unfortunately I haven't made controls work with these a-views.****************************************************************has-pixmap, has-colortableThese are mixed into objects which have a pixmap or a colortable as one oftheir components. This includes windows, gworlds, pixmaps, icons, and thelike. The general problem with doing a mixin of this sort is that the pixmapis often embedded within a handle which is not necessarily locked. In orderto get a pointer to the pixmap, we need to lock whatever handles we access onthe way to finding the pixmap. The function (with-locked-parent objectfunction) is specialized for each type of object to do this. The methods formore specific classes are nested inside the scope of those for more specificclasses. To get the colortable of a window we first lock its pixmap, and then itscolortable.The interface is in the form of two macro forms, with-pixmap, andwith-colortable. Each takes a clos object which has the appropriate mixin andbinds a variable to a pointer (not a handle) to the pixmap. Inside thedynamic scope of one of these forms you can get the pointer with(pixmap-pointer object) or (colortable-pointer object), and get the handlewith (pixmap-handle object) or (colortable-handle object).For example:; get the number of entries in the colortable of an a-window(setq window (make-instance 'a-window))(with-colortable (c window)  (pref c :colortable.ctsize))There are a couple of routines written for colortables, but in generalthis area is not well fleshed out.colortable-to-array ((c has-colortable) &optional array)return an array of the color values (in the form of mcl colors, not rgb records)in the colortable. You can pass array, if you don't want it allocated.array-to-colortable ((c has-colortable) &optional array)Takes the colors in array and puts them into the colortable. Note thatyou out to change the colortable seed when you do this (see inside mac)array-to-colortable-scale-value ((c has-colortable) scale value &optional array)Set the colortable from the array but scale the colors first. There are threescaling modes. The value is from 0 to 1, where 0 is unchanged, and 1 is total change.Scale can be :saturation (makes it become grayer), :lightness (make it becomelighter), or value (makes it darker).colortable-seed, (setf colortable-seed)Gets and sets the colortable seed.****************************************************************gworldGworlds are apple's offscreen window environment. A gworld has everything youneed to be able to draw to. You can focus a gworld in the same way you wouldfocus a window. You should read apple's documention in inside mac 6 for detailed information.There are several parameters which control a gworld. These can be given nondefault values by passing new values as keywords to the make instance formfor a gworld.Size The bigger it is, the more drawing area you have, and the morememory you use.Depth This is the number of bits per pixel. The more bits per pixel, the morememory is used, and the more distinct color can be drawn. Acceptable values are1,2,4,8,16, and 32. A 32 bit gworld is really a direct color, 8bits for each ofr,g,b.Gdevice If you pass a gdevice, the gworld is set up to match the gdevice whichyou pass, and copybits between the gworld and the window are allegedly faster. Iprobably don't do all I can to fully optimize this, for instance when the windowis moved, the gworld needs to be updated so that the pixels are aligned the sameway in the window and the gworld, and I don't bother about it. If you don't passa depth or gdevice, the maxdevice is used. IfColortable You can pass a colortable to be used with the gworld. As per theapple specs, this colortable is *copied* and put into the gworld. The colortabledefaults to the appropriate system palette.Gray? Set this to t if you want the gworld to use the grayscal colortables.There are two ways to create these. One is through make-instance, for example(make-instance 'gworld :depth 8 :gray? t :size #@(50 60))Alternately you can create a temporary gworld, one which is deallocatedouside the scope of the form. In the following g is bound to the gworld. Youwill be unhappy if you use the gworld outside the scope of the form.(with-temporary-gworld (50 60 8 g) (print g))To draw on a gworld, use with-focused-gworld. The following example showsa typical use. (rect and rect2 are routines to stuff temporary scratch rects).(setq w (make-instance 'window :color-p t))(with-temp-gworld (100 100 8 g)         ; allocate the world  (with-focused-gworld (g)              ; focus, so you can draw    (rlet ((rgb :rgbcolor))      (#_eraserect (rect #@(100 100)))          ; draw a red and green circle      (color-to-rgb *red-color* rgb)      (#_rgbforecolor rgb)      (#_paintoval (rect #@(100 100)))      (color-to-rgb *green-color* rgb)      (#_rgbforecolor rgb)      (#_paintoval (rect #@(50 50)))      (with-pixmap (gworld-pix g)       ; now copy between the gworld pixmap and        (with-focused-view w            ; the window pixmap          (with-pixmap (window-pix w)            (#_copybits gworld-pix window-pix              (rect #@(100 100))              (rect2 #@(100 100))             #$srccopy (%null-ptr))))))))  Note that it is usually not necessary to do this. Using a sheet-viewautomatically handles the drawing via copybits to the superior view.Other functions:update-gworld ((g gworld) &key colortable depth size gdevice)Changes the parameters of the gworld. Don't forget to redraw the contents. Ithink that sometimes it is preserved, but don't count on it. Note that themacptr to the gworld is changed in this operation, so don't grap the pixmapbefore you do this and expect it to be valid after this is done.dispose-gworld ((g gworld))Free up the space used by the gworld. You don't have to do this, as the garbagecollector will free it when there are no more references, but if you areallocating a lot of them for temporary use then you probably out to.****************************************************************a-base,sheet-base  (Overview of Sheets)a-base is the base class on which a-views and sheet-views are built. a-window,a-view, sheet-base, sheet-view, shaped-view, and shaped-window all inherit fromthis.sheet-base is the base on which views which have pixmaps to draw on -sheet-views (draw on their gworlds), and a-windows (draw on the screen). Theword sheet is meant to suggest a sheet of paper.You don't instantiate either of these classes.Replacements for several important window functions are specialized onarguments of these type, including set-view-container, set-view-size,view-window, invalidate-region, validate-region, set-view-level,install-view-in-sheet, initialize-instance.Implementation OverviewThe biggest change in the implementation of a-views, compared to regularviews, is the addition of the notion of the view-sheet. With standard viewsyou have a wptr which is the grafport of the window you are in. When you wantto focus you set the port change the coordinate system to that of the viewand draw. However, with the advent of sheet-views, you don't always draw on the screen.I introduce the view-sheet, which is the view which you draw on. When youfocus, now you set the port to the grafport of that view (which can be eithera gworld or a window), change the coordinate system, and draw. Validation and invalidation need to be changed in such an environment. Withthe old views, the process of updating the screen was mediated byinvalidate-view which called #_invalrect. Invalrect would land up posting awindow-update event, which would be processed by mcl (asynchronously),leading to calls of view-draw-contents.However, the meaning of view draw-contents is different in the presense ofsheet-views. When the view being drawn is a sheet-view, and the view is notinvalidated, we want to just copy the bits of the image up to the view-sheetabove it (eventually the screen). If we just use #_invalrect then we don'tknow which sheets need to be redraw vs which don't. So instead, invalidating is propogated upwards through the view-sheet hierarchy.Invalidating a view causes the invalid region to be stored and a correspondinginvalidation of the view-supersheet. Then view-draw-contents is only called onthose view-sheets that really need to be redrawn are. As usual, after anydrawing is done the images are copied using copybits.This invalidation and redrawing method requires some rethinking of the wayyou draw in windows. Currently, if you draw to a view it immediately appearson the window. Now, if you draw on a sheet-view, it doesn't appear on thescreen. In order to appear on the screen, its contents need to be copied upthe sheet-view hierarchy until they appear on the screen. In practice whatthis means is that if you want a view to be redrawn (for instance the objectwhich it represents has changed), you should call invalidate-view on theview, rather than view draw contents. If you do focus and draw in the viewyourself, you should invalidate the view-supersheet when you are done,forcing the image to be copied upwards.With sheet views, the function install-view-in-window is changed toinstall-view-in-sheet, likewise remove-view-from-window is changed toremove-view-from-sheet. It is these changes which make use of controls ina-windows not function. I believe that this can be done, but it requires somework. In particular, controls like calling #_invalrect, which is a no-no.****************************************************************a-view, a-windowUse just as you would views and windows, in cases where you want to usesheet-views.****************************************************************sheet-viewSheet-views have a gworld which their subviews draw onto. You can access thegworld with (gworld view). You can draw directly on the sheet by usingwith-focused-gworld on the gworld of the sheet. Sheet views can only be placed in a-windows, and as subviews of a-views.Bug: I probably should have made it that focusing on the sheet-view causesyou to draw on it, but at some time during development this was changed, andI can't remember why. Since a lot of code might break, I'm leaving it thisway. Anyways, the preferred way of using sheet-views is to have them havesubviews which aren't sheets, and the behaviour in that case is correct.Maybe another bug: I don't trust set-view-scroll-position when applied tosheet-views. It may work, but if you want something that scrolls, I suggestyou put a view that scrolls as a subview of the sheet.Here is an example.(defclass click-move-drag ()  ())(defmethod view-click-event-handler ((v click-move-drag) where)  (if (eq (find-clicked-subview v where) v)    (loop with initialpos = (view-position v)          with initialmouse = (view-mouse-position (view-container v))          for mouse = (view-mouse-position (view-container v))          for pos = (add-points initialpos (subtract-points mouse initialmouse))          do           (set-view-position v pos)          (event-dispatch)          until (not (mouse-down-p)))    (call-next-method)));; a sheet which serves as a buffer(defclass bullseye-sheet (sheet-view)  ());; the view that draws.(defclass bullseye-view (click-move-drag a-view) ());; drawing on the gworld here, not the window.(defmethod view-draw-contents ((b bullseye-view))  (rlet ((rgb :rgbcolor))    (loop with width = (point-h (view-size b))          with height = (point-v (view-size b))          for ring from 4 downto 1          for color = (if (eq color *red-color*) *white-color* *red-color*)          with delta-radius = (floor ring 8)          for radius = (make-point (* (floor width 8) ring) (* (floor height 8) ring))          for center = (make-point (floor width 2) (floor height 2))          do           (#_rgbforecolor (color-to-rgb color rgb))          (#_paintoval (rect (subtract-points center radius)                             (add-points center radius))))));; make it in a window. click and drag the view. (make-instance 'a-window   :view-size #@(200 200)  :view-subviews (list (make-instance 'bullseye-sheet                          :view-size #@(200 200)                         :view-subviews (list (make-instance 'bullseye-view                                                 :view-size #@(100 100))))));; Compare this to without a buffer.(make-instance 'a-window   :view-size #@(200 200)  :view-subviews (list  (make-instance 'bullseye-view                           :view-size #@(100 100))))The examples in the file-set "sheet-example" define several more examples ofhow to use sheets.****************************************************************Sheet-view functionscopybits-modeCalled to compute what the copybits mode should be when copying bits from thesheet to the supersheet. Various effects are possible with the use of thearithmetic modes. See the circles example from sheet-example file set.copy-bits ((source sheet-view) (dest a-base)              source-pixmap dest-pixmap source-rect dest-rect)Called by the update system to do the actual copy bits. You can specializethis if you want to do some sort of special effects, for instance using#_copydeepmask instead of #_copybits, or use a maskregion.The default method does  (#_copybits source-pixmap dest-pixmap source-rect dest-rect    (copybits-mode source) (%null-ptr))****************************************************************shaped-view, shaped-windowA shaped view is a view which has a shape defined by a region, instead of a rectangle.The shape is computed by the (region view), which you specialize.Here is an example. You can click and drag to move the window. Click in thelittle round close box to close it.(defclass round-view (click-move-drag shaped-view) ()  (:default-initargs :view-size #@(100 100)));; the form drawing-region turns the drawing commands inside its;; body into a region, which it returns. The region is gcable by the;; lisp garbage collector. Note the use of the slot value of view-size, rather;; than the function. The function computes the size from the region, so we can't use;; it in the calculation of the region.(defmethod region ((v round-view))   (drawing-region    (#_frameoval (rect (slot-value v 'view-size)))));; draw a funky graduated border. The (region v) is cached, so make a copy before;; munging.(defmethod view-draw-contents ((v round-view))  (rlet ((r :rgbcolor))    (let ((rgn (region v)))      (let ((rgncpy (make-region nil)))        (#_copyrgn rgn rgncpy)        (loop for color in (list *black-color* *dark-gray-color* *gray-color*)              do               (#_rgbforecolor (color-to-rgb color r))              (#_framergn rgncpy)              (#_insetrgn rgncpy 1 1))        (#_disposergn rgncpy))))  (call-next-method)); build the window on shaped view, but make sure it has shaped window mixed in as well.(defclass round-window (round-view shaped-window) ()); build the close box out of the same stuff(defclass round-close-box (round-view) ()  (:default-initargs :view-size #@(10 10 ))); make the close box close.(defmethod view-click-event-handler ((r round-close-box) where)  (declare (ignore where))  (window-close (view-window r))); let 'er rip.(make-instance 'round-window   :view-subviews (list (make-instance 'round-close-box                          :view-position #@(45 5))))****************************************************************shrink-wrapped-view, shrink-wrapped-windowA shaped-view which takes its shape from the union of the shapes of its subviews.Bugs: There seems to sometimes be race conditions. Without-interrupts in theinitialize-instance method seems to help. Also, setting the view position aftercreation of one of the subviews of a shrink-wrapped window doesn't properlychange the shape of the window. Removing all the subviews and reinstalling them(inside a without-interrupts), seems to do the job.For example, here is a window with three disjoint circles. The little one isthe close box.(defclass double-round-window (shrink-wrapped-window)  ());; this stuff is touchy. I put a without interrupts to be safe.(defmethod initialize-instance ((v double-round-window) &rest args)  (without-interrupts   (apply #'call-next-method v :view-subviews           (list (make-instance 'round-close-box :view-position #@(0 0))                (make-instance 'round-view :view-position #@(10 0))                (make-instance 'round-view :view-position #@(110 0)))          args)));; move when we click and drag.(defmethod view-click-event-handler ((v double-round-window) where)  (loop with initialpos = (view-position v)        with initialmouse = (view-mouse-position (view-container v))        for mouse = (view-mouse-position (view-container v))        for pos = (add-points initialpos (subtract-points mouse initialmouse))        do         (set-view-position v pos)        (event-dispatch)        until (not (mouse-down-p)))  (call-next-method))(make-instance 'double-round-window)                          ****************************************************************quickdraw-bottleneck-mixinThe qdprocs (as documented in IM, in the quickdraw section), are the routineswhich are called to do base level quickdraw operations. In windows which havequickdraw-bottleneck-mixin as a component, generic function of the same namesare called with the same argument list as that in IM. There are a couple of differences. The verb argument becomes a keyword, insteadof an enum type, as per below *qd-verb-names* -> #(:frame :paint :erase :invert :fill).The first argument of the generic functions is the window. In all casescall-next-method executes the standard quickdraw procedure.Bottlenecks are installed where there is a method for the bottleneck other thanthe default. That way performance on non trapped procs is not affectedIt is essential that you read the quickdraw documentation in IM to understandthe purpose of this.For example,In other code, I use a method on rectproc to determine where textedit is doingits drawing. Textedit doesn't generate invalidate events, but it always erasesa rectangleHere is an example. Click in the window. I used eval-enqueue because the firsttime I didn't and it crashed. This is not that surprising since we are callinglisp from a place deep in the rom.(defclass rectproc-window (quickdraw-bottleneck-mixin window)  ())(defmethod rectproc ((w rectproc-window) verb rect)  (eval-enqueue `(format t "Rectangle ~A in window ~A with verb ~A~%"                         ,(rect-string rect) ,w ,verb))  (call-next-method))(defmethod view-click-event-handler ((w rectproc-window ) where)  (#_framerect (rect where (add-points where #@(30 30)))))(make-instance 'rectproc-window)