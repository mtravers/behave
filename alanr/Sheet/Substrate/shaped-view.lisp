(in-package :ccl)#|A general wdef routine. Add four classes of viewshaped-view : A view which has a region method. Stuff in this view is clipped to the              regionshrink-wrapped-view: A view which gets its shape from the union of the shapes of                     its (shaped) subviewsshaped-window: A window which has a region defining itshrink-wrapped-window: A window which gets its shapes from it subviews ; returns a region which is created by the drawing-commands in body.drawing-region &rest bodyA protocol for window sizing needs to be designed. On the one hand, adding a regionwhich goes outside the window should change the size of the window, on theother hand you may want to set the window size, affecting the parts, affectingthe size of the window.ok... The protocol is that set-view-size acts via content-region. Namely, theaction of set-view size may change the size of the content region, which, upon updatehas a new bounding box, which is the new view size.position|#;; ****************************************************************;; Dealing with the wdef.;; Our wdef is simplified, in a sense, from the usual. The complete window;; is considered to be content region. The structure region is the same as the;; content region. Note that it can't be eq, since the window manager expects this to be two;; regions. So have the content region functions duplicate the content region for the ;; structure region.;; We draw only one thing in response to the wdef request, that;; is the window frame, either highlighted or not. Most of this is adapted from ;; windoids.lisp;; Important note: The content region position is in global coordinates.;; Don't draw the frame#|(defpascal user-defined-window-wdef (:word variation :ptr wptr :word message                                           :long parameter :long)  (declare (ignore variation))  (let ((w (window-object wptr)))    (without-interrupts     (case message       (#.$wHit         (return-from user-defined-window-wdef          (if (#_ptinrgn                parameter               (content-region w))            #$wincontent            #$wnohit)))       (#.$wCalcRgns         (setf (rref wptr windowrecord.contrgn) (content-region w))        (setf (rref wptr windowrecord.strucrgn) (structure-region w))))     0)))|#;; patched by bw to look more like the windoid-wdef;; for some reason this works and the above does not(defpascal user-defined-window-wdef (:word variation :ptr wptr :word message                                           :long parameter :long)  (declare (ignore variation))    (without-interrupts     (let ((w (window-object wptr))           (result 0))       (case message         (#.$wHit           (setf result (if (#_ptinrgn                             parameter                            (content-region w))                         #$wincontent                         #$wnohit)))         (#.$wCalcRgns           (setf (rref wptr windowrecord.contrgn) (content-region w))          (setf (rref wptr windowrecord.strucrgn) (structure-region w))))       result)))(defun make-user-defined-window-handle (&aux (h (#_NewHandle :check-error 6)))  (with-dereferenced-handles ((p h))    (%put-word p #x4ef9)    (%put-ptr p user-defined-window-wdef 2))  h)(defvar *user-defined-wdef-handle* (make-user-defined-window-handle))(def-load-pointers user-defined-wdef-handle ()  (setq *user-defined-wdef-handle* (make-user-defined-window-handle)));; ****************************************************************;; Definition of a shaped view.;; A shaped view clips to a region instead of a rectangle. When shaped views are;; subviews of shaped-windows the window becomes the union of the shapes of the subviews.(defclass shaped-view (a-view)  ((region :initarg :region :initform nil :accessor region)   (view-size :initarg :view-size :initform nil :accessor view-size)))(defmethod view-size ((v shaped-view))  (subtract-points (rref (region v) :region.rgnbbox.bottomright)                    (rref (region v) :region.rgnbbox.topleft)));; This is the interface to the MCL window system. Compute view region seems to;; be undocumented, but is the method that is called to compute the clip region.;; The reason that we don't use the clip region as the shape is that MCL uses that;; internally, and I want to avoid incompatibilities. I've used the MCL;; version as a basis, so watch out if this changes in the lisp. This is only really;; necessary if you use shaped views as subviews of other views. If you are using them;; as subviews of a user defined window then it is redundant. The first clause of the;; is what changed from the original.(defmethod compute-view-region ((view shaped-view) rgn container)  (when rgn    (if container      (let* ((origin (view-origin-slot view))             (container-origin (view-origin container))             (tl (add-points (view-position view)                             (subtract-points origin container-origin)))             (br (add-points tl (view-size view)))             (offset (subtract-points container-origin origin))             (container-region (view-clip-region container)))        (declare (ignore br))        ;; use the region of the view, instead of a rectangle        (#_copyrgn (region view) rgn)        (#_offsetrgn :ptr rgn :long tl)        ;; This below (from original) does an intersection with the view container.        (#_OffsetRgn :ptr rgn :long offset)        (#_SectRgn :ptr rgn :ptr container-region :ptr rgn)        (#_OffsetRgn :ptr rgn :long (subtract-points #@(0 0) offset)))      (#_SetRectRgn :ptr rgn :word -32767 :word -32767 :word 32767 :word 32767)))  rgn);; cache the region slot(defmethod region :around ((v shaped-view))  (or (slot-value v 'region)      (setf (region v) (call-next-method))));; default shape of a shaped view is just a rectangle the size of the view(defmethod region ((v shaped-view))  (let ((rgn (make-region)))    (#_setrectrgn :ptr rgn :long #@(0 0) :long (slot-value v 'view-size))    rgn))(defmethod invalidate-shape ((v shaped-view))  (setf (region v) nil)  (let ((container (view-container v)))    (when (and container (shrink-wrapped? container))      (invalidate-shape container))));; ****************************************************************;; A shrink-wrapped-view gets its shape by unioning the shapes of it's subviews;; Subviews *must* be shaped-views.(defclass shrink-wrapped-view (shaped-view) ())(defmethod shrink-wrapped? ((thing shrink-wrapped-view)) t)(defmethod shrink-wrapped? ((anything-else t)) nil)  (defmethod region ((v shrink-wrapped-view))  (unless (slot-value v 'region)    (let ((region (make-region)))      (loop for part across (view-subviews v)            for position = (view-position part)            for part-region = (region part)            do            (#_offsetrgn part-region (point-h position) (point-v position))            (#_unionrgn region part-region region)            (#_offsetrgn part-region (- (point-h position)) (- (point-v position))))      region)))(defmethod set-view-container ((v view) (container shrink-wrapped-view))  (if (typep v 'shaped-view)    (call-next-method)    (error "Sorry, only shaped views can be made subviews of shrink-wrapped views")))(defmethod set-view-container ((v shaped-view) (container shrink-wrapped-view))  (without-interrupts   (call-next-method)   (invalidate-shape v)))(defmethod set-view-container ((v shaped-view) (null null))  (if (view-container v)    (without-interrupts      (invalidate-shape (view-container v))     (call-next-method))    (call-next-method)))(defmethod add-subviews :after ((v shrink-wrapped-view) &rest args)  (declare (ignore args))  (invalidate-shape v));; ****************************************************************;; Definition of the user defined window. The whole window is considered;; content. We handle all drawing movement, etc.;; structure region and content region are defined in inside mac. The structure region;; is usually the window frame and title bar. The content region is the rest.;; I dispose with this distinction, letting up build are own window abstractions;; in lisp. Thus the structure and content region are the same.(defclass shaped-window (a-window shaped-view)  ((content-region :initarg :content-region :initform nil :reader read-content-region                   :accessor content-region)   (structure-region :initarg :structure-region :initform nil :accessor                      structure-region)   (invalid-regions :initarg :invalid-regions :initform nil :accessor                     invalid-regions))  (:default-initargs :color-p t));; The initialization requires installing the window defproc (as for windoids).;; Also, any window parts are added to the window at this time.(defmethod initialize-instance ((w shaped-window) &rest initargs &key                                 (window-show t))  (without-interrupts   (apply #'call-next-method w :window-show nil initargs))  (let ((wptr (wptr w)))    (when wptr                          ; may have failed      (rset wptr :windowrecord.windowdefproc *user-defined-wdef-handle*)      (setf (slot-value w 'grow-icon-p) nil)      (if window-show (window-select w))      )));; from windoids. because when window is closed gc is eventually called, which;; and disposing can call the defproc(defmethod window-close :before ((w shaped-window))  (window-hide w)  (let ((wptr (wptr w)))    (rset wptr           :windowrecord.WindowDefProc          (rref %temp-port% :windowrecord.WindowDefProc))    ))(defmethod window-close :after ((w shaped-window))  ;; free up as much space as possible. Assume that the current content region  ;; and structure region are disposed of by closewindow.  (dolist (r (invalid-regions w))    (dispose-region r))  (setf (invalid-regions w) nil));; force the content region to change(defmethod update-content-region ((w shaped-window))  (let ((old-content (content-region w)))    (invalidate-shape w)    (without-interrupts     (let* ((rgn (content-region w))            (h (- (rref rgn region.rgnbbox.right) (rref rgn region.rgnbbox.left)))            (v (- (rref rgn region.rgnbbox.bottom) (rref rgn region.rgnbbox.top))))       (setf (slot-value w 'view-size ) (make-point h v))       (compute-view-region w (view-clip-region w) nil)       (#_sizewindow (wptr w) h v t))     (when old-content       (#_diffrgn old-content (content-region w) old-content)       (#_paintbehind (wptr w) old-content))     (dolist (r (invalid-regions w))       (dispose-region r))     (setf (invalid-regions w) nil)     ))) ;; This computes the content region from the subviews, by unioning them.;; subview regions are drawn with respect to the view coordinate system.(defmethod content-region :before ((w shaped-window))  (unless (read-content-region w)    (let ((content-region (make-region nil)))      (#_copyrgn (region w) content-region)      (#_offsetrgn content-region (point-h (view-position w)) (point-v (view-position w)))      (setf (content-region w) content-region)      (setf (structure-region w) (make-region nil))      (#_copyrgn content-region (structure-region w))      )))(defmethod invalidate-shape ((w shaped-window))  (let ((cr (content-region w))        (sr (structure-region w))        (r (region w)))    (when r (pushnew sr (invalid-regions w) :test #'eql))    (when sr (pushnew sr (invalid-regions w) :test #'eql))    (when cr (pushnew cr (invalid-regions w) :test #'eql))    (setf (content-region w) nil (structure-region w) nil (region w) nil))  (call-next-method));; modified from MCL sources. Maybe this should be a documented function.(defmethod compute-view-region ((w shaped-window) rgn container)  (declare (ignore container))  (when rgn    (let* ((content-region (content-region w))              (topleft (rref content-region region.rgnbbox.topleft))           (bottomright (rref content-region region.rgnbbox.bottomright))           (position (view-position w)))      (#_SetRectRgn :ptr rgn :long (subtract-points topleft position)       :long (subtract-points bottomright position))      rgn)));; Periodically check for invalidated content region and reconstitute if necessary(defmethod window-event ((w shaped-window))  (unless (read-content-region  w)    (update-content-region w))  (call-next-method)  )(defmethod view-click-event-handler ((w shaped-window) where)  (declare (ignore where))  (if (and (control-key-p) (command-key-p) (option-key-p))    (drag-outline-to-change-position w)    (call-next-method)))(defmethod window-show ((w shaped-window))  (let ((hidden (not (window-shown-p w))))    (call-next-method)    (when (and hidden (window-shown-p w))      (invalidate-shape w))))(defmethod window-select ((w shaped-window))  (let ((hidden (not (window-shown-p w))))    (call-next-method)    (when (and hidden (window-shown-p w))      (invalidate-shape w))));;****************************************************************;; shrink-wrapped-window, floating (windoid) etc.(defclass floating-shaped-window (shaped-window windoid) ())(defclass shrink-wrapped-window (shaped-window shrink-wrapped-view) ())(defclass floating-shrink-wrapped-window (shrink-wrapped-window windoid) ())  ;; bw 7/25/96;; added this rather than try to get the superclasses right(defmethod set-view-position ((w shaped-window) h &optional v)  (cond ((numberp h)         (setq h (make-point h v))         (#_MoveWindow (wptr w) (point-h h) (point-v h) nil)         h)        (t (set-view-position w (center-window (view-size w) h)))));; ****************************************************************;; utilities;; drag a copy of the outline of a window. Specialize outline region to;; change the shape of the dragger. Returns a point representing the amount the;; outline was moved.(defmethod drag-outline ((w shaped-window ))  (let* ((r (outline-region w nil)) ;; don't make it gcable         (start (view-mouse-position w))         (global (%local-to-global (wptr w) start)))    (with-port (window-manager-port)      (let ((grayregion (#_getgrayrgn)))        (let ((rect (rect (rref grayregion region.rgnbbox.topleft)                          (rref grayregion region.rgnbbox.bottomright))))          (#_cliprect rect)          (#_draggrayrgn r  global rect rect 0 (%null-ptr)))))    (dispose-region r)    (subtract-points (view-mouse-position w) start)));; create a new region here(defmethod outline-region ((w shaped-window) &optional (gcable t))  (let ((rgn (make-region gcable)))    (#_copyrgn (content-region w) rgn)    rgn))(defmethod drag-outline-to-change-position ((w shaped-window))  (set-view-position w (add-points (view-position w) (drag-outline w))))#|add-subviewsremove-subviews  set-view-container    install-view-in-window    remove-view-from-window|#