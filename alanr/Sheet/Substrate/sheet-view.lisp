#|*********************************************************************************Author: Alan Ruttenberg, Interval Researchemail:  alanr-d@media.mit.eduCreated: Sunday August 4,1991*********************************************************************************|#(in-package :ccl);; ****************************************************************;; Class of view which has its own sheet.;; a sheet-view is really a view, but has a gworld backing.(defclass sheet-view (sheet-base a-view gworld)   ((invalid-region :initarg :invalid-region :initform nil :accessor invalid-region)   (copybits-mode :initarg :copybits-mode :initform #$srccopy :accessor copybits-mode)))(defmethod sheet? ((s sheet-view)) t)(defmethod initialize-instance ((v sheet-view)  &rest args &key (view-size #@(100 100)))  (setf (invalid-region v) (make-region t))  (apply #'call-next-method v :size view-size args)  (setf (slot-value v 'wptr) (gworld v))  (multiple-value-call 'set-view-font-codes v (font-codes (view-font v)))  (with-focused-view v    (#_cliprect (rect view-size))    (#_eraserect (rect view-size))    ));; validating a sheet simply adds the region th invalid region. When the view is part;; of a window, the window validation will force an update event, which will force;; view draw contents, which will update the sheet.(defmethod update-gworld ((view sheet-view) &key)  (let* ((wptr (gworld view))         (subviews-with-this-wptr (subviews-with-wptr view wptr)))    (without-interrupts     (call-next-method)     (loop for v in subviews-with-this-wptr           with new-wptr = (gworld view)           do (setf (slot-value v 'wptr) new-wptr))))  );; Tuesday September 24,1996 alanr: don't do anything if the new size is the;; same as the last.(defmethod set-view-size ((view sheet-view) h &optional v)  (unless (eql (@! h v) (view-size view))    (without-interrupts     (update-gworld view  :size (make-point h v))     ;(setf (slot-value view 'wptr) (gworld view)) ;; ??? Sunday March 8,1992 1:28pm     )    (call-next-method)    (invalidate-corners view #@(0 0) (size view) t)))(defmethod subviews-with-wptr ((view simple-view) wptr)  (declare (ignore wptr))  nil)(defmethod subviews-with-wptr ((view view) wptr)  (loop for v across (view-subviews view)        when (eq (wptr v) wptr)        append (cons v (subviews-with-wptr v wptr))))(defmethod invalidate-region ((v sheet-view) region &optional (erase-p t))  (when region    (when erase-p       ;; alanr Friday December 15,1995       (with-sheets-focused-gworld (v)         (when (view-clip-region v)          (#_setclip (view-clip-region v)))        '(#_setorigin :long #@(0 0))        (#_erasergn region)))    (#_unionrgn region (invalid-region v) (invalid-region v))))(defmethod validate-region ((v sheet-view) region)  (when region    (#_diffrgn (invalid-region v) region (invalid-region v))));; This is painful. What we have to do is simulate the update process on;; a window. In order to do update, all clips to the draw done by focus view;; have to *also* be clipped by the visrgn or update region. In a window this is;; done by beginupdate. Here we assume that an update event is occuring when we;; get a call to view-draw-contents with a non empty invalid-region. When this happens,;; we set the visrgn ourselves (this is undocumented for gworld - a note should be ;; sent to apple asking them to give us an official accessor). So we save the old visrgn,;; intersect it with the invalid region. All the drawing of subviews occurs below this;; function. When we are done (making sure it happens via unwind-protect) we retore the ;; original visrgn(defmethod view-draw-contents ((view sheet-view) &aux                                   (wptr (wptr view)))  (when wptr    (let ((visrgn (invalid-region view)))      (with-macptrs ((cliprgn (rref wptr grafport.cliprgn)))        (let ((savevis (rref (gworld view) cgrafport.visrgn)))          (unless (#_emptyrgn visrgn)            (#_sectrgn savevis visrgn visrgn)            (setf (rref (gworld view) cgrafport.visrgn) visrgn))          (unwind-protect            (dovector (subview (view-subviews view))              (view-focus-and-draw-contents subview visrgn cliprgn))            (setf (rref (gworld view) cgrafport.visrgn) savevis)))))))(defmethod view-focus-and-draw-contents ((view sheet-view) &optional visrgn cliprgn)  (with-focused-view view    (if (regions-overlap-p visrgn cliprgn)      (view-draw-contents view)      )));; Amazing but true facts;; If the mask region has a bbox which is smaller than the pixmap, then it pays to;; only copy in the area of the region. This would of course be generaly faster. One;; would think that the quickdraw software would optimize the call to copybits ;; automatically to take into account the mask region.;; However this does not seem to be true. If the source and dest rects are the ;; size of the pixmaps, instead of the size of the much smaller region, then;; the copy goes much slower, as evidenced by there being more tearing in the image.;; Moral : Don't count on quickdraw to do the right thing.(defmethod view-position-wrt-super ((v sheet-view) &optional super)  (let ((sheet (or super (view-supersheet v))))    (loop for view = v then (view-container view)          with coord = #@(0 0)          until (eq view sheet)          do           (setq coord (add-points coord (view-position view)))          finally (return coord))))(defmethod foreground-color ((anything t))  *black-color*)(defmethod background-color ((anything t))  *white-color*)(defmethod set-background-color ((anything t))  (rlet ((rgb :rgbcolor))    (#_rgbbackcolor (color-to-rgb (background-color anything) rgb)))) (defmethod set-foreground-color ((anything t))  (rlet ((rgb :rgbcolor))    (#_rgbforecolor (color-to-rgb (foreground-color anything) rgb))));; Monday April 29,1996;; I am truly sorry about this. I just can't figure out how to deal with view-origin;; issues. So I give this hook so that I can at least do what needs to be done;; in my other projects(defmethod kludge-offset ((v sheet-view))  #@(0 0))(defmethod view-draw-contents :after ((v sheet-view))  (let ((rgn (make-region t)))    (let ((sheet (view-sheet (view-container v))))      (when sheet        (with-pixmap (gwpix v)          (with-focused-view sheet            (with-pixmap (sheetpix (if (typep sheet 'window) *desktop* sheet))              (let* ((topleft (view-position-wrt-super v sheet))                     (bottomright (add-points topleft (view-size v)) ))                (when (typep sheet 'window)                  (focus-view *desktop*)                  (#_setorigin :long (@- #@(0 0) (view-position sheet)))                  (#_getclip rgn)                  (#_setclip (rref (wptr sheet) :cgrafport.visrgn)))                (let ((source-rect (rect (view-size v)))                      (dest-rect (rect2 topleft bottomright))                      (region (invalid-region sheet)))                  ;; intersect the source and dest rect with the invalid region bbox                  ;; to minimize blt time.                  (let ((offset (kludge-offset v)))                    (#_offsetrect dest-rect (@h offset) (@v offset))                    (rlet ((r :rect :topleft (rref region region.rgnbbox.topleft)                              :bottomright (rref region region.rgnbbox.bottomright)))                      (#_sectrect dest-rect r dest-rect)                      (#_offsetrect :ptr r :long (@- (subtract-points #@(0 0) topleft) offset))                      (#_sectrect source-rect r source-rect)                      )                    (set-foreground-color v)                    (set-background-color v)                    (copy-bits v sheet gwpix sheetpix source-rect dest-rect)                     )))              (when (typep sheet 'window)                (#_setclip rgn)                (#_setorigin 0 0))))))))  (#_setrectrgn (invalid-region v) 0 0 0 0))(defmethod copy-bits ((source sheet-view) (dest a-base)                       source-pixmap dest-pixmap source-rect dest-rect)  (#_copybits source-pixmap dest-pixmap source-rect dest-rect    (copybits-mode source) (%null-ptr)))#|(defmethod focus-view ((view sheet-view) &optional font-view &aux wptr)  (without-interrupts   ;; reset the origin of the last wptr (this is a concession to gwviews).   ;; assumption is that they are all originally 0 based.    ;; doesn't hurt for windows.   (#_setorigin :long #@(0 0))    (if (setq wptr (wptr view))     (progn       ;; this little piece of joy has a reason.        (let ((container (view-container view)))         (when container           (let* ((csheet (view-sheet container))                  (cwptr (wptr csheet)))             (set-gworld cwptr)             (let ((convert (convert-coordinates-up #@(0 0) view csheet)))               (#_setorigin :long (subtract-points #@(0 0) convert))               ))))       (let* ((org (view-origin view)))         (set-gworld wptr)         (#_SetOrigin :long org)         (let ((vcr (view-clip-region view)))           (and vcr (#_SetClip :ptr vcr)))         (when font-view           (multiple-value-bind (ff ms) (view-font-codes font-view)             (when ff               (set-wptr-font-codes wptr ff ms))))         (setq *current-font-view* font-view)         (setq *current-view* view)))     (focus-view nil font-view))))|#