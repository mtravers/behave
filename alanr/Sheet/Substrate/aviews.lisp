;-*- Mode: Lisp; Package: CCL -*-(in-package :ccl);; ****************************************************************;;;; Author: Alan Ruttenberg, Interval Research;; email:  alanr@media.mit.edu;; © Copyright Apple Computer 1991-1992;; Written to support work in the Apple Human Interface Group;;;; Thursday April 18,1996 alanr in view-sheet your sheet is only valid if you are in a window or sheet, ;; hence the added check for (wptr view) ;; Tuesday April 9,1996. Check that there is a clip region before using it in ;; invalidate-region :after;; Sunday January 22,1995: Pass erase-p upwards unless we are invalidating from;; a sheet to a window, in which case it is not needed;; Created: Thursday July 18,1991;; ;; ****************************************************************;; Lets go for it!;; version of views which works with gworlds and sheets. We will call this view;; hierarchy aviews, and awindows. Aviews and view shoudn't be mixed. The intention;; is to have views in lisp in the long run gain the functionality I develop here,;; so that I can get rid of them.;; abase is for all aview things, includeing sheets and windows(defclass a-base (view)  ((view-sheet :initarg :view-sheet :initform nil :accessor view-sheet)   ));; your sheet is only valid if you are in a window or sheet, ;; hence the added check for (wptr view) (defmethod view-sheet :around ((view a-base))  (and (wptr view) (call-next-method)))(defmethod region ((view a-base))  (let ((rgn (or (view-get view :view-region)                 (view-put view :view-region (make-region t)))))    (#_setrectrgn :ptr rgn :long #@(0 0) :long (view-size view))    rgn))(defmethod dispose :before ((view a-base))  (do-subviews (sub view) (dispose sub)))(defmethod dispose ((v a-base)) (when (next-method-p) (call-next-method)))    ;; sheet-base is for all sheet things, including windows(defclass sheet-base (a-base) ())(defmethod initialize-instance :before ((v sheet-base) &key)  (setf (view-sheet v) v));; aview are actually views, not windows(defclass a-view (a-base) ())(defclass sheet-base (a-base) ());; awindows are windows, not views(defclass a-window (sheet-base window has-pixmap) ()  (:default-initargs :color-p t))#|;; changed by bw(defclass a-window (window sheet-base has-pixmap) ()  (:default-initargs :color-p t))|#(defmethod invalid-region ((v a-window))   (rref (wptr v) :cgrafport.visrgn))(defmethod sheet? ((s sheet-base)) t)(defmethod sheet? (anything-else) (declare (ignore anything-else)) nil)(defmethod window? ((w a-window)) (declare (ignore w)) t)(defmethod window? (anything-else) (declare (ignore anything-else)) nil)(defmethod dialog-item-enabled-p ((view a-base)) t);; ****************************************************************;; Super sheet is the sheet is your containing sheet.(defmethod view-supersheet ((v a-view))  (if (window? v) nil (view-sheet v)))(defmethod view-supersheet ((v sheet-base))  (let* ((c (view-container v))         (sheet (and c (view-sheet c))))    (and c (wptr c) sheet)))(defmethod view-supersheet ((null null)) null)(defmethod view-supersheet ((w a-window)) nil)(defmethod view-sheet ((null null)) null);; ****************************************************************;; install-view-in-sheet replaces install-view-in-window(defmethod remove-view-from-sheet ((view a-view))   (setf (wptr view) nil)  (setf (view-sheet view) nil)  (do-subviews (sub view)    (remove-view-from-sheet sub)))(defmethod remove-view-from-sheet ((w a-window))   (error "Doesn't make sense"))(defmethod remove-view-from-sheet ((v simple-view))   (error "Doesn't make sense"));; view-sheet is what you draw on. Note: Conceptually you draw on the gworld of a sheet.;; the sheet system arranges for the sheet to be drawn on its supersheet.(defmethod install-view-in-sheet ((view a-base) (sheet sheet-base))  ; not gcable, since remove-view-from-window explicitly disposes of it  (setf (view-clip-region-slot view) (make-region nil))   (setf (view-valid view) (cons nil (view-valid (view-container view))))  (setf (wptr view) (if (window? sheet) (wptr sheet) (gworld sheet)))  (unless (sheet? view)    (setf (view-sheet view) sheet))  (do-subviews (sub view)    (install-view-in-sheet sub (if (sheet? view) view sheet))))(defmethod install-view-in-sheet ((w a-window) anything)   (declare (ignore anything))  (error "Doesn't make sense"));; Friday December 15,1995 alanr. Be nicer. Try to have view coexist with a-views(defmethod install-view-in-sheet ((v simple-view) anything)   (install-view-in-window v anything)); (error "Doesn't make sense"));; ****************************************************************;; calculate view-window, by hopping by sheet. ;; Monday January 23,1995: Handle the case where there is no intermediate;;   sheet between view and window.(defmethod view-window ((v a-base))   (let ((supersheet (view-supersheet v)))    (if supersheet      (view-window supersheet)      (and (view-container v)           ;; Tuesday May 21,1996 was wrong for uninstalled sheet views           (view-window (view-container v)))))) ;; was: (view-sheet v))))(defmethod view-window ((w a-window)) w)(defmethod view-window ((null null)) null);; ****************************************************************;; Set-view-container becomes knowledgable about the fact that there can be sheets;; between the view and the window. Remove dependency on windows.;(defmethod set-view-container ((view a-view) anything) ;  (declare (ignore anything));  (call-next-method);  );(defmethod set-view-container (anything (new-container a-view)) ;  (declare (ignore anything));  (call-next-method);  )(defmethod set-view-container ((w a-window) anything)   (declare (ignore anything))  (error "Windows can't be contained"))  (defmethod set-view-container ((view a-base) (new-container a-base) &aux                               (old-container (view-container view)))  (when (neq new-container old-container)    (when new-container      (when (or (eq new-container view)                (view-contains-p view new-container))        (error "Attempt to make ~s contain itself." view)))    (without-interrupts     (when old-container       (invalidate-view view t)       (setf (slot-value old-container 'view-subviews)             (delete view (view-subviews old-container) :test #'eq))       (when (view-sheet view)         (remove-view-from-sheet view))       (set-view-container-slot view nil))     (when new-container       (let ((siblings (view-subviews new-container))             (containing-sheet (if (sheet? new-container)                                  new-container                                 (view-sheet new-container))))         (vector-push-extend view siblings)         (set-view-container-slot view new-container)         (when containing-sheet           (install-view-in-sheet view containing-sheet)           (invalidate-view view)))))    (refocus-view view))  new-container);; Tuesday April 9,1996 alanr: have set-view-position not care whether there is ;; a view-container(defmethod set-view-position ((view a-view) h &optional v                              &aux                              (pt (make-point h v))                              (old-position (view-position view)))  (unless (eql pt old-position)    (without-interrupts     (if (wptr view)       (progn         (invalidate-view view t)         (setf (slot-value view 'view-position) pt)         (invalidate-view view)         (make-view-invalid view))       (progn         (setf (slot-value view 'view-position) pt)))))  (refocus-view view)  pt);; ****************************************************************;; View mouse position needs to be calculated with the window(defmethod view-mouse-position ((v a-view))  (let* ((window (view-window v))         (window-ptr (wptr window)))    (when window-ptr      (with-focused-view window        (rlet ((pt :pointer))          (#_GetMouse :ptr pt)          (convert-coordinates-down (%get-long pt) window v))))));; ****************************************************************;; (in)validate-region;; Any validation gets passed upwards to its sheet. The old version of ;; the validation code talks to the wptr of the view window.;; validating a view (as opposed to a sheet) does nothing locally.(defmethod invalidate-region ((v a-base) region &optional erase-p)  (declare (ignore region erase-p)))(defmethod validate-region ((v a-base) region)  (declare (ignore region)));; This does the work of passing the validation upward. Only sheets actually do any work.;; Before you poss the region up, intersect with the view clip region. Use *tmp-rgn* to;; pass the region upwards.;; Don't pass erase-p upwards, since erasure gets done on the lowest sheet.;; Sunday January 22,1995: Pass erase-p upwards unless we are invalidating from;; a sheet to a window, in which case it is not needed;; Tuesday April 9,1996. Check that there is a clip region before using it.(defmethod invalidate-region :after ((v a-base) region &optional erase-p)  (let ((super (view-supersheet v)))    (when super      (let ((offset (convert-coordinates-up #@(0 0) v super))            (vc (view-clip-region v)))        (let ((rgn *temp-rgn*))          (if vc            (#_sectrgn region (view-clip-region v) rgn)            (#_copyrgn region rgn))          (#_offsetrgn :ptr rgn :long offset)          (invalidate-region super rgn (if (and (typep v 'sheet-view)                                                 (window? super))                                         nil erase-p)))))))(defmethod validate-region :after ((v a-base) region)  (let ((super (view-supersheet v)))    (when super      (let ((offset (convert-coordinates-up #@(0 0) v super)))        (let ((rgn *temp-rgn*))          (#_sectrgn region (view-clip-region v) rgn)          (#_offsetrgn :ptr rgn :long offset)          (validate-region super region ))))));; validating a window. Mostly just call the toolbox.(defmethod invalidate-region ((view a-window) region &optional erase-p)  (when (wptr view)    (with-focused-view view      (without-interrupts;; the following sectrgn is necessary because of a bug in quickdraw, nearly as ;; I can tell. If the region is goes outside the bounds of the visrgn, then;; the invalidation can get dropped (I noticed this with textedit). Perhaps they;; are using a signed comparison. The regions being dropped were someting like;; (-32k foo) (32k foo+10)       (#_sectrgn (rref (wptr view) :cgrafport.visrgn) region *temp-rgn*)       (#_InvalRgn :ptr *temp-rgn*)       (let ((wir (window-invalid-region view)))         (when wir           (#_unionrgn *temp-rgn* wir wir)))       (when erase-p         (let* ((erase-rgn (window-erase-region view)))           (when erase-rgn             (#_UnionRgn :ptr region :ptr erase-rgn :ptr erase-rgn))))))))(defmethod validate-region ((view a-window) region)  (when (wptr view)    (with-focused-view view      (without-interrupts       (#_ValidRgn :ptr region)       (let* ((erase-rgn (window-erase-region view))              (org (view-origin view)))         (let ((wir (window-invalid-region view)))           (when wir             (#_diffrgn wir *temp-rgn* wir)))         (when erase-rgn           (unless (eql #@(0 0) org)             (#_OffsetRgn :ptr region               :long (subtract-points (view-origin view) org)))           (#_DiffRgn :ptr erase-rgn :ptr region :ptr erase-rgn)))))));; ****************************************************************;; patch view-draw-contents(defmethod view-draw-contents ((view a-view) &aux                                   (wptr (wptr view)))  (when wptr    (let ((visrgn (rref (wptr view) :grafport.visrgn)))      (dovector (subview (view-subviews view))        (view-focus-and-draw-contents subview visrgn  nil)))));; magic. A window keeps its visrgn in sync with the origin. So;; the visrgn is set up once for the sheet, then upon inquiry offsets itself according;; to the current origin. Asking for (invalid-region (view-sheet view)) is;; wrong, since that is in the coordinates of the sheet, and we want it in the;; coordinates of the view. We also improve on the version for views by;; checking if the view region and the visrgn intersect, rather than checking whether;; the container clip region and the visrgn overlap, which leads to potentially;; unnecessary drawing.(defmethod view-focus-and-draw-contents ((view a-view) &optional visrgn cliprgn)  (declare (ignore cliprgn))  (with-focused-view view    (if (regions-overlap-p visrgn (view-clip-region view))      (view-draw-contents view)      )));; ****************************************************************;; compute-view-region;; Modifications are necessary since you might be drawing to a view which is ;; not rooted in a window. The change: Don't intersect your clip region with the container;; region when the  container is a sheet. Reasoning: The sheet will clip automatically.#|;; original method(defmethod compute-view-region ((view view) rgn container)  (when rgn    (if container      (let* ((origin (view-origin-slot view))             (container-origin (view-origin container))             (tl (add-points (view-position view)                             (subtract-points origin container-origin)))             (br (add-points tl (view-size view)))             (offset (subtract-points container-origin origin))             (container-region (view-clip-region container)))        (#_SetRetcRgn :ptr rgn :long tl :long br)        (#_OffsetRgn :ptr rgn :long offset)        (#_SectRgn :ptr rgn :ptr container-region :ptr rgn)        (#_OffsetRgn :ptr rgn :long (subtract-points #@(0 0) offset)))      (#_SetRectRgn :ptr rgn :word -32767 :word -32767 :word 32767 :word 32767)))   rgn);; Typo method(defmethod compute-view-region ((view a-view) rgn container)  (when rgn    (if container      (let* ((origin (view-origin-slot view))             (container-origin (view-origin container))             (tl (add-points (view-position view)                              (subtract-points origin container-origin)))             (br (add-points tl (view-size view)))             (offset (subtract-points container-origin origin))             (container-region (view-clip-region container)))        (#_SetRectRgn rgn :long tl :long br)        (#_OffsetRgn rgn :long offset)        (unless (sheet? container)          (#_SectRgn rgn container-region rgn))        (#_OffsetRgn :ptr rgn :long (subtract-points #@(0 0) offset))        (#_SetRectRgn  rgn -32767 -32767 32767 32767))))  rgn)|#(defmethod compute-view-region ((view a-view) rgn container)  (when rgn    (if container      (let* ((origin (view-origin-slot view))             (container-origin               (if (sheet? container)                #@(0 0)                (view-origin container)))             (tl (add-points (view-position view)                              (subtract-points origin container-origin)))             (br (add-points tl (view-size view)))             (offset (subtract-points container-origin origin))             (container-region (view-clip-region container)))        (#_SetRectRgn :ptr rgn :long tl :long br)        (#_OffsetRgn :ptr rgn :long offset)        (unless (sheet? container)          (#_SectRgn rgn container-region rgn))        (#_OffsetRgn :ptr rgn :long (subtract-points #@(0 0) offset)))      (#_SetRectRgn  rgn -32767 -32767 32767 32767)))  rgn)(defmethod compute-view-region ((view a-window) rgn container)  (declare (ignore container))  (when rgn    (let ((topleft (view-origin view)))      (#_SetRectRgn :ptr rgn                  :long topleft                  :long (add-points topleft (view-size view)))))  rgn);; ****************************************************************;; compute-view-origin needs to be changed;; The assumption in the ord one was that the view origin was with respect ;; to the base window. However any sheet is like a base window.(defmethod compute-view-origin ((view a-view) container)  (setf (view-origin-slot view)        (if container          (if (sheet? container)            (subtract-points (view-scroll-position view)                                       (view-position view))            (add-points (subtract-points (view-scroll-position view)                                         (view-position view))                        (view-origin container)))          (view-scroll-position view))));; ****************************************************************;; Patch set-view-level;; don't invalidate the container - invalidate the siblings. In fact this is;; still too much redrawing, since not all siblings touch. Really you only need to;; invalidate only those siblings which form a connected region with the  original view;;;; You don't want to invalidate the view since if it is a sheet, then it doesn't redraw ;; the subviews.(defmethod set-view-level ((view a-base) level)  (without-interrupts   (let ((container (view-container view)))     (when container       (let* ((siblings (view-subviews container))              (cnt (length siblings))              (new-pos (- cnt 1 level))              (old-pos (position view siblings :test #'eq))              (i old-pos))         (when (or (< new-pos 0) (>= new-pos cnt))           (error "Level out of range."))         (cond ((eql new-pos old-pos)                (return-from set-view-level level))               ((< new-pos old-pos)                (while (< new-pos i)                  (setf (aref siblings i) (aref siblings (1- i)))                  (decf i)))               (t                        ; (> new-pos old-pos)                (while (> new-pos i)                  (setf (aref siblings i) (aref siblings (1+ i)))                  (incf i))))         (setf (aref siblings new-pos) view)         (do-subviews (sv container)           (invalidate-view sv))         ))))  level);; Set-view-size does a naughty #_invalrgn, instead of invalidate-region of the sheet.(defmethod set-view-size ((view a-base) h &optional v &aux                             (pt (make-point h v))                             (container (view-container view)))  (unless (eql pt (view-size view))    (without-interrupts     (if (not (view-sheet view))       (setf (slot-value view 'view-size) pt)       (progn         (let ((clip-region (view-clip-region view))               (old-region *temp-rgn*)               (temp-region *temp-rgn-2*))           (when clip-region             (#_CopyRgn :ptr clip-region :ptr old-region))           (setf (slot-value view 'view-size) pt)           (make-view-invalid view)           (setq clip-region (view-clip-region view))   ; for simple-views           (when clip-region             (#_XorRgn :ptr clip-region :ptr old-region :ptr temp-region))           (if container             (progn               (#_OffsetRgn :ptr temp-region :long (view-position view))               (invalidate-region container temp-region t))             (invalidate-region view temp-region t))           ))))    (refocus-view view))  pt)(defmethod set-view-size ((w a-window) h &optional v &aux                           (new-size (make-point h v)))  (unless (eql new-size (view-size w))    (without-interrupts     (set-view-size-internal w new-size)     (make-view-invalid w)))  (refocus-view w)  new-size);; ****************************************************************;; patches to convert-coordinates so that we don't have to rely on view;; origin(defun convert-coordinate-offset (sub super)  (loop for current = sub then vc        for vc = (view-container current)        with offset = 0        when (eq current super) do (return-from convert-coordinate-offset offset)        do (setq offset (add-points offset (subtract-points                                            (view-position current)                                            (view-scroll-position current))))        until (null vc))  nil)(defun convert-coordinates-up (coordinates sub super)  ;; assume from is below to  (let ((offset (convert-coordinate-offset sub super)))    (and offset (add-points offset coordinates))))(defun convert-coordinates-down (coordinates super sub)  (let ((offset (convert-coordinate-offset sub super)))    (and offset (subtract-points coordinates offset))))(defun convert-coordinates (point from to)  (or (convert-coordinates-up point from to)      (subtract-points       #@(0 0) (convert-coordinates-up (subtract-points #@(0 0) point) to from))))(defmethod find-clicked-subview ((view view) where)  (do* ((subviews (view-subviews view))        (i (1- (the fixnum (length subviews))) (1- i))        subview)       ((< i 0) view)    (declare (fixnum i))    (setq subview (aref subviews i))    (when (point-in-click-region-p subview where)      (return (find-clicked-subview               subview (convert-coordinates-down where view subview))))));; ****************************************************************;; patch set-view-scroll-position to not use naughty _InvalRgn(defmethod set-view-scroll-position ((view a-view) h &optional v (scroll-visibly t)                                     &aux                                     (pt (make-point h v))                                     (container (view-container view))                                     delta                                     (old-sc-pos (view-scroll-position view))                                     (wptr (wptr view)))  "h and v are in view's coordinates"  (without-interrupts   (when wptr     (with-focused-view view       (setq delta (subtract-points old-sc-pos pt))       (when scroll-visibly         (let* ((rgn *temp-rgn*))           (if container             (rlet ((r :rect                       :topleft old-sc-pos                       :bottomright (add-points old-sc-pos (view-size view))))               (#_ScrollRect :ptr r :long delta :ptr rgn)               (invalidate-region view rgn)               ;; this is a little more expensive, replace it sometime with               ;; something which just copies the part from the sheet.               (unless (window? (view-sheet view))                 (invalidate-view view t)))             (progn               (#_ScrollRect :ptr (rref wptr windowrecord.portrect)                            :long delta :ptr rgn)               (invalidate-region view rgn))))));       (view-move-origin view delta container)     (make-view-invalid view))   (setf (view-scroll-position view) pt)   (refocus-view view))  pt)