;; ****************************************************************;;;; Author: Alan Ruttenberg, MIT Media Lab;; email:  alanr-d@media.mit.edu;;;; Written to support work in the Apple Human Interface Group. ;;;; Thursday April 18,1996 alanr: add option for gworld not to erase when updated. ;; ****************************************************************(in-package :ccl)(defclass gworld (has-pixmap)  ((pixmap-handle :initarg :pixmap-handle :initform nil :accessor pixmap-handle)   (gworld :initarg :gworld :initform nil :accessor gworld)   (depth :initarg :depth :initform nil :accessor depth)   (gdevice :initarg :gdevice :initform (%null-ptr) :accessor gdevice)   (colortable :initarg :colortable :initform nil :accessor colortable)   (gray? :initarg :gray? :initform nil :accessor gray?)   (size :initarg :size :initform #@(100 100) :accessor size)   (temporary? :initarg :temporary? :initform nil :accessor temporary?)))(defmethod with-locked-parent :around ((g gworld) continuation)  (if (pixmap-handle g)    (call-next-method g continuation)    (unwind-protect       (progn        (let ((pm (#_getgworldpixmap (gworld g))))          (#_lockpixels pm)          (setf (pixmap-handle g) pm))        (call-next-method g continuation))      ;; have to be careful here. don't use pm, since it may have been deallocated in body,       ;; due to updategworld      (#_unlockpixels (#_getgworldpixmap (gworld g)))      (setf (pixmap-handle g) nil))));; ****************************************************************;; gworld methods. If the colortable is not specified, then it defaults to the system colortable;; for the appropriate depth, unless gray? is t, in which it is a grayscale colortable. A colortable;; doesn't make sense for depths greater than 8(defun default-gdevice ()  (#_getmaxdevice (rect #@(-32000 -32000) #@(32000 32000))))(defmethod initialize-instance ((g gworld) &rest args)  (apply 'shared-initialize g t args)  (if (depth g)    (assert (member (depth g) '(1 2 4 8 16 32) :test 'eql) ((depth g))            "depth of a gworld needs to be a power of 2")      (progn      (when (%null-ptr-p (gdevice g))        (setf (gdevice g) (default-gdevice)))      (setf (depth g) (rref (rref (gdevice g) gdevice.gdpmap) pixmap.pixelsize))))  (unless (colortable g)    (default-colortable g))  (unless (gworld g)    (allocate-gworld g))  (call-next-method))(defmethod default-colortable ((g gworld))  (setf (colortable g)        (if (gray? g)          (#_getctable (case (depth g)                         (2 34)                         (4 36)                         (8 40)                         ((1 16 32) #-POWERPC (%null-ptr) #+POWERPC 0)))          (#_getctable (case (depth g)                         (2 2)                         (4 4)                         (8 8)                         ((1 16 32) #-POWERPC (%null-ptr) #+POWERPC 0))))))(defmethod allocate-gworld-failed ((g gworld) result-code)  (error "allocate-gworld failed! error number ~a" result-code))  (defmethod allocate-gworld ((g gworld))  (rlet ((gw :pointer))    (let ((result (#_newgworld gw                   (depth g)                    (rect (size g))                   (colortable g)                   (gdevice g)                   (if (temporary? g) 4 0))))      (when (not (zerop result)) (allocate-gworld-failed g result))      (setf (gworld g) (gworld-macptr (%get-ptr gw) t)))))#|(defmacro with-focused-gworld ((gworld) &body body)  (let ((p (make-symbol "PORT"))        (g (make-symbol "GDEVICE")))    `(rlet ((,p :pointer) (,g :pointer))       (unwind-protect          (progn           (require-trap #_lockpixels (#_getgworldpixmap (gworld ,gworld)))           (require-trap #_getgworld ,p ,g)           (require-trap #_setgworld (gworld ,gworld) (%null-ptr))                      ,@body           )         (require-trap #_setgworld (%get-ptr ,p) (%get-ptr ,g))         (require-trap #_unlockpixels (#_getgworldpixmap (gworld ,gworld)))))))|#;; Friday December 15,1995 alanr said uncle on with-focused-gworld.;; now depends on offscreen.lisp(defmacro with-sheets-focused-gworld ((gworld) &body body)  (let ((gws (make-symbol "WITH-SHEET-FOCUSED-GWORLD-GWORLD")))    `(let ((,gws (gworld ,gworld)))       (with-focused-gworld (,gws)         ,@body))))(defmethod update-gworld-failed ((g gworld) result-code)  (error "updategworld failed! error number ~a" result-code))      ;; to be back compatible(defmethod gworld-erase-on-update? ((g gworld)) t)(defmethod update-gworld ((g gworld) &key colortable depth size gdevice)  (let ((oldsize (size g)))    (assert (gworld g) () "Gworld should be non nil here!")    (rlet ((gw :pointer))      (%put-ptr gw (gworld g))      (let ((result-code             (#_updategworld gw              (setf (depth g) (or depth (depth g)))              (rect (setf (size g) (or size (size g))))              (setf (colortable g) (or colortable (colortable g)))              (setf (gdevice g) (or gdevice (gdevice g)))              (gworld-update-method g))))        (when (minusp result-code)          (update-gworld-failed g result-code))                ;; do a setf of the macptr, so that we preserve whatever flags we had        ;; primarily the disposegworld flag, if it exists.        (%setf-macptr (gworld g) (%get-ptr gw))        ))    ;; Saturday September 21,1996 alanr: Finally! Erase the newly created area of the    ;; gworld bny default. Previously existing areas remain painted.    (let ((region (%new-rgn)))      (#_rectrgn region (rect (size g)))      (#_diffrgn region (rect-region oldsize) region)      (with-sheets-focused-gworld (g)        (let ((r (rect (or size (size g) ))))          (#_cliprect r)          (#_erasergn region)          (#_disposergn region)          ;; we don't always want to erase!          (when (gworld-erase-on-update? g)            (#_eraserect r)))))))#| Saturday September 21,1996(defmethod update-gworld ((g gworld) &key colortable depth size gdevice)  (assert (gworld g) () "Gworld should be non nil here!")  (rlet ((gw :pointer))    (%put-ptr gw (gworld g))    (let ((result-code           (#_updategworld gw            (setf (depth g) (or depth (depth g)))            (rect (setf (size g) (or size (size g))))            (setf (colortable g) (or colortable (colortable g)))            (setf (gdevice g) (or gdevice (gdevice g)))            (gworld-update-method g))))      (push (cons (gworld-update-method g) result-code) h)      (when (minusp result-code)        (update-gworld-failed g result-code))      ;; do a setf of the macptr, so that we preserve whatever flags we had      ;; primarily the disposegworld flag, if it exists.      (%setf-macptr (gworld g) (%get-ptr gw))      ))  (with-sheets-focused-gworld (g)    (let ((r (rect (or size (size g) ))))      (#_cliprect r)      ;; we don't always want to erase!      (when (gworld-erase-on-update? g)        (#_eraserect r)))))|#(defmethod dispose ((g gworld))  (when (gworld g)    ;; turn off the dispose flag, since we are disposing by hand.    (dispose-gworld (gworld g)))  (setf (gworld g) nil))(defmethod gworld-update-method ((v gworld))  #-ccl-3(ash 1 #$clippix)  #+ccl-3 #$clippix)(defmacro with-temp-gworld ((width height depth gworld &optional ctable gray?) &body body)  `(with-temp-gworld-1 ,width ,height ,depth ,ctable ,gray?     #'(lambda(,gworld)         ,@Body)))(defun with-temp-gworld-1 (width height depth ctable gray? continuation)  (let ((world (make-instance 'gworld :size (make-point width height) :depth depth :colortable ctable :gray? gray?                           :temporary? t)))    (rlet ((r :rect :topleft #@(0 0) :bottomright (make-point width height)))      (unwind-protect        (progn          (with-sheets-focused-gworld (world)            (#_cliprect r)            (#_eraserect r))          (funcall continuation world))        (dispose world)))))(defmethod unfocus-view ((view gworld) next-view next-font-view)  (declare (ignore next-view next-font-view))  (#_setorigin :long #@(0 0)))