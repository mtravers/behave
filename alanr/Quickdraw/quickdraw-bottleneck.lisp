(in-package :ccl);;********************************************************************************;; Quickdraw-Bottleneck.lisp;; © Copyright Apple Computer 1991-1992;; Author: Alan Ruttenberg (alanr@media.mit.edu);; Monday June 10,1991 ;; Written to support work in the Apple Human Interface Group.;; This file implements a lisp interface to the qdprocs. The qdprocs (as documented in IM, in the;; quickdraw section), are the routines which are called to do base level quickdraw operations. In;; windows which have quickdraw-bottleneck-mixin as a component, generic function of the same names;; are called with the same argument list as that in IM. ;; There are a couple of differences. The verb argument becomes a keyword, instead of an enum type, as;; per below *qd-verb-names*. The first argument of the generic functions is the window. In all;; cases call-next-method executes the standard quickdraw procedure.;; Bottlenecks are installed where there is a method for the bottleneck other than the default.;; It is essential that you read the quickdraw documentation in IM to understand the purpose of this;; file.;;********************************************************************************;; stubs: safe versions in case we are not using sheet-views(defmethod view-sheet ((v t)) (view-window v))(defmethod gworld ((v t)) (error "this view has no gworld"))(defvar *qd-verb-names* (vector :frame :paint :erase :invert :fill));; Templates for each of the standard quickdraw procedures, following ff-call syntax. The first elements of;; the list are the names of the generic functions. For each of these a pascal glue function;; with "P-" prepended to the name is also created.(defvar *bottleneck-methods*   '((textProc :word bytecount :pointer textbuf :long numer :long denom nil)    (lineProc :long newpoint nil)    (rectProc :word verb :pointer rect nil)    (rRectProc :word verb :pointer rect :word ovalwidth :word ovalheight nil)    (ovalProc :word verb :pointer rect nil)    (arcProc :word verb :pointer rect :word startangle :word arcangle nil)    (polyProc :word verb :pointer polygon-handle nil)    (rgnProc :word verb :pointer region-handle nil)    (bitsProc :pointer bitmap :pointer srcrect :pointer dstrect :word integer :pointer mask-region nil)    (commentProc :word kind :word datasize :pointer datahandle nil)    (txMeasProc :word bytecount :pointer textbuf :pointer numer :pointer denom :pointer info :word)    (getPicProc :pointer datapointer :word bytecount nil)    (putPicProc :pointer datapointer :word bytecount nil)));;********************************************************************************;; quickdraw-bottleneck-mixin ;; keep two copies of the qdprocs, one with the original methods, for call-next-method, and ;; one which gets installed into the window.(defclass quickdraw-bottleneck-mixin ()  ((qdprocs :accessor qdprocs)   (original-qdprocs :accessor original-qdprocs)   (bottleneck-methods :accessor bottleneck-methods )   (sheets-loaded :accessor sheets-loaded :allocation :class)   ))(defmethod initialize-instance ((w quickdraw-bottleneck-mixin) &key)  (without-interrupts   (call-next-method)   (setf (bottleneck-methods w) *bottleneck-methods*)   (allocate-qdprocs w)   ;; cache whether sheet-views are loaded   (setf (sheets-loaded w) (find-class 'sheet-view nil))   (if (and (sheets-loaded w) (typep w 'sheet-view))     (setf (rref (gworld w) windowrecord.port.grafprocs) (qdprocs w))     (setf (rref (wptr w) windowrecord.port.grafprocs) (qdprocs w)))   (install-bottlenecks w)));; allocate the records as gcable.(defmethod allocate-qdprocs ((w quickdraw-bottleneck-mixin))  (let ((use (gcable-pointer (make-record :cqdprocs)))        (original (gcable-pointer (make-record :cqdprocs))))    (with-focused-view w      (if (or (not (typep w 'window)) (window-color-p w))        (progn          (#_setstdcprocs (setf (qdprocs w) use))          (#_setstdcprocs (setf (original-qdprocs w) original)))        (progn          (#_setstdprocs (setf (qdprocs w) use))          (#_setstdprocs (setf (original-qdprocs w) original)))))));; installing the bottlenecks means putting the address of a defpascalled routing into the ;; qdprocs record. (defmethod install-bottlenecks ((w quickdraw-bottleneck-mixin))  (loop for method in (bottleneck-methods w)        for count from 0        do        (when (install-bottleneck? w  method)          (%put-ptr (qdprocs w)                     (symbol-value (intern (format nil "P-~A" (symbol-name (car method))) 'ccl))                    (* 4 count)))));; install the bottleneck if there is a method which is applicable which is not the primary;; method defined for the mixin.(defmethod install-bottleneck? ((w quickdraw-bottleneck-mixin) method)  (let ((applicable-methods         (compute-applicable-methods           (symbol-function (car method))           (list* w (loop for i below (/ (- (length method) 2) 2) collect t)))))    (flet ((non-base-method (method)             (not              (and (null (method-qualifiers method))                    (eq  (car (method-specializers method)) (find-class 'quickdraw-bottleneck-mixin))))))      (some #'non-base-method applicable-methods))))  (defmethod (setf wptr) :after (new-wptr (w quickdraw-bottleneck-mixin))  (without-interrupts   (when (and new-wptr (slot-boundp w 'qdprocs))     (if (and (sheets-loaded w) (typep w 'sheet-view))       (setf (rref (gworld w) windowrecord.port.grafprocs) (qdprocs w))       (setf (rref (wptr w) windowrecord.port.grafprocs) (qdprocs w))))));; A bottleneck is run on the current view, if it accepts the bottleneck, or its sheet, which must accept it.(defmethod accept-bottleneck? ((anything t))  nil)(defmethod accept-bottleneck? ((v quickdraw-bottleneck-mixin)) t)  ;;****************************************************************;; install the default methods. We make two routines: One which is a pascal interface for the routine.;; the only complication is that verb gets translated into a keyword. The pascal method just calls the;; generic function. The generic function calls the original qdprocs routine whcih we have stashed;; in the instance.(progn  (macrolet ((defpascal-for-bottleneck-form (method)               `(defpascal ,(intern (format nil "P-~A" (symbol-name (car method))) 'ccl)                       ,(rest method)                  (let ((applicand (if (accept-bottleneck? *current-view*)                                     *current-view*                                      (view-sheet *current-view*))))                    (when (and *current-view* (accept-bottleneck? applicand))                      (,(car method) applicand                       ,@(loop for (nil name) on (butlast (rest method)) by #'cddr                                if (eq name 'verb)  collect '(svref *qd-verb-names* (ldb (byte 8 8) verb))                               else collect name))))))             (default-method-for-bottleneck-form (method)               `(defmethod ,(car method) ((w quickdraw-bottleneck-mixin)                                           ,@(loop for (nil name) on (butlast (rest method)) by #'cddr collect name))                  (ff-call (rref (original-qdprocs w)                                  ,(intern (format nil "QDPROCS.~A" (symbol-name (car method))) 'keyword))                           ,@(substitute '(ash (position verb *qd-verb-names*) 8) 'verb (rest method))))))    (macrolet ((generic-and-defpascal-standard-quickdraw-procedure-definitions ()                 `(progn ,@(loop for method in *bottleneck-methods*                                 collecting (list 'default-method-for-bottleneck-form method)                                 collecting (list 'defpascal-for-bottleneck-form method)))))      (generic-and-defpascal-standard-quickdraw-procedure-definitions))))                                #||;;****************************************************************;; test(defun trace-quickdraw ()  (loop for (method) in *bottleneck-methods*        do (eval `(trace ,method))))(defclass qdwindow (quickdraw-bottleneck-mixin window) ())(defmethod install-bottleneck? ((w qdwindow) method)  t)(defun test ()  (make-instance    'qdwindow   :view-subviews   (list (make-instance 'editable-text-dialog-item :view-size #@(100 100) :view-position #@(0 0)))))         ||#                 