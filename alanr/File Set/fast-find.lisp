(in-package :ccl);; alanr@media.mit.edu;; Interface to the system's fast file finder: #_pbcatsearch(defun volume-refnum (vol)  (unless (char= (char vol (1- (length vol))) #\:)    (setq vol (format nil "~a:" vol)))  (%stack-iopb (pb np)     (%path-to-iopb vol pb)     (%get-signed-word pb $iovrefnum)))(defun fast-find-file (&rest args                         &key                          (volume :all)                         (name-matches nil)                         (name-is nil)                         (date-low 0 date-low-supplied?)                         (date-high (get-universal-time) date-high-supplied?)                          (max-matches 100)                          (max-search-time :none)                          (search-buffer-size (expt 2 15))                          (find-files t find-files-supplied-p)                          (find-folders nil find-folders-supplied-p))    (when (eq volume :all)    (loop for disk in (mapcar 'namestring (directory "*:"))          for found = (apply 'fast-find-file :volume disk args)          when found do (return-from fast-find-file found)          finally (return-from fast-find-file nil)))  (when (listp volume)    (loop for disk in volume          for found = (apply 'fast-find-file :volume disk args)          when found do (return-from fast-find-file found)          finally (return-from fast-find-file nil)))                               (when (and find-folders-supplied-p (not find-files-supplied-p))    (setq find-files nil))    (when (and name-matches name-is)    (error "You can specify either an exact match or a partial match, but not both"))    (when date-low-supplied? (setq date-low (universal-to-mac-time date-low)))  (setq date-high (universal-to-mac-time date-high))    (let ((search-criteria           (logior (if (or find-files find-folders) #$fsSBFlAttrib 0)                 (if (or date-low-supplied? date-high-supplied?)                   #$fsSBFlCrDat                   0)                 (if name-matches #$fsSBPartialName 0)                 (if name-is #$fsSBfullName 0)))        (match-results (#_newptr (* max-matches (record-length :fsspec))))        (search-buffer (#_newptr search-buffer-size)))    (declare (dynamic-extent match-results search-buffer))    (rlet ((paramblock :hparamblockrec)           (searchlow :cinfopbrec)           (searchhigh :cinfopbrec))            (with-pstr (namestr (or name-matches name-is ""))        ;; completion routine        (setf (rref paramblock hparamblockrec.ioCompletion) (%null-ptr))                ;; no volume name, use vrefnum        (setf (rref paramblock hParamblockrec.ioNamePtr) (%null-ptr))                ;; now the vrefnum        (setf (rref paramblock hParamblockrec.iovrefnum) (volume-refnum volume))                ;; point to the results buffer        (setf (rref paramblock hParamblockrec.iomatchptr) match-results)                ;; tell it how many results at once        (setf (rref paramblock hParamblockrec.ioReqMatchCount) max-matches)                (setf (rref paramblock hParamblockrec.iosearchbits) search-criteria)        (setf (rref paramblock hParamblockrec.iosearchinfo1) searchlow)        (setf (rref paramblock hParamblockrec.iosearchinfo2) searchhigh)                ;; how much time to spend (-1 means as much as is needed)        (setf (rref paramblock hParamblockrec.ioSearchTime)               (if (eql max-search-time :none) 0 max-search-time))                ;; If you continue on, this becomes relevant. In any case it        ;; needs to be initialized to 0        (setf (rref paramblock hParamblockrec.ioCatPosition.initialize) 0)                ;; point to the search buffer        (setf (rref paramblock hParamblockrec.ioOptBuffer) search-buffer)                ;; let it know how much of a search buffer you have.        (setf (rref paramblock hParamblockrec.ioOptBufSize) search-buffer-size)                        ;; now set up the search criteria record lower bound        ;; let it know the string to match        (if (or name-matches name-is)          (setf (rref searchlow cinfopbrec.ioNamePtr) namestr)          (setf (rref searchlow cinfopbrec.ioNamePtr) (%null-ptr)))                ;; look for files        (setf (rref searchlow cinfopbrec.ioFlAttrib) (if find-files #x00 #x10))                ;; low date        (setf (rref searchlow cinfopbrec.ioFlCrDat) date-low)                ;; now the upper bound. Nil for the name. ioflattrib is a !mask!. There are other         ;; file informations that on can search on.        (setf (rref searchhigh cinfopbrec.ionameptr) (%null-ptr))        (setf (rref searchhigh cinfopbrec.ioFlAttrib) (if (and find-files find-folders) 0 #x10))        (setf (rref searchhigh cinfopbrec.ioFlCrDat) date-high)                (let ((res (#_PBCatSearch  paramblock))) ;; add :asynch as first keyword to do asynchronously          (case res            (-39 nil)            (-50 (error "error -50"))            (otherwise (error "error ~a" res))))                (let ((count (rref paramblock hparamblockrec.ioActMatchCount)))          (loop for i from 0 below count                collect (%path-from-fsspec (%inc-ptr match-results (* (record-length :fsspec) i)))))                ))));; simpler version#|(defun fast-find-file (&key (volume "ccl:")                               (name-is "load-newer.lisp")                               (max-matches 20)                               (search-buffer-size 16384))  (let ((search-criteria (+ #$fsSBFlAttrib #$fsSBfullName))        (match-results (#_newptr (* max-matches (record-length :fsspec))))        (search-buffer (#_newptr search-buffer-size)))    (rlet ((paramblock :hparamblockrec) (searchlow :cinfopbrec) (searchhigh :cinfopbrec))      (with-pstr (namestr name-is)        (setf (rref paramblock hparamblockrec.ioCompletion) (%null-ptr))        (setf (rref paramblock hParamblockrec.iovrefnum)               (%stack-iopb (pb np) (%path-to-iopb volume pb) (%get-signed-word pb $iovrefnum)))        (setf (rref paramblock hParamblockrec.iomatchptr) match-results)        (setf (rref paramblock hParamblockrec.ioReqMatchCount) max-matches)        (setf (rref paramblock hParamblockrec.iosearchbits) search-criteria)        (setf (rref paramblock hParamblockrec.iosearchinfo1) searchlow)        (setf (rref paramblock hParamblockrec.iosearchinfo2) searchhigh)        (setf (rref paramblock hParamblockrec.ioSearchTime) 0)        (setf (rref paramblock hParamblockrec.ioCatPosition.initialize) 0)        (setf (rref paramblock hParamblockrec.ioOptBuffer) search-buffer)        (setf (rref paramblock hParamblockrec.ioOptBufSize) search-buffer-size)        (setf (rref searchlow cinfopbrec.ioNamePtr) namestr)        (setf (rref searchlow cinfopbrec.ioFlAttrib) 0)        (setf (rref searchhigh cinfopbrec.ionameptr) (%null-ptr))        (setf (rref searchhigh cinfopbrec.ioFlAttrib) #x10)        (progn (case (#_PBCatSearch  paramblock) (-39 nil) (otherwise (error "error with pbcatsearch")))               (loop for i from 0 below (rref paramblock hparamblockrec.ioActMatchCount)                     collect (%path-from-fsspec (%inc-ptr match-results (* (record-length :fsspec) i)))))        ))))|#