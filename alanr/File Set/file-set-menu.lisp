;; ****************************************************************;;;; Author: Alan Ruttenberg, Interval Research;; email:  alanr@media.mit.edu;;;; Monday, October 16, 1995 Kotik: change so you get submenu of file set commands if;;    you hold down control while pressing on the menu header "FileSets".;;    This is done by having two separate lists of file set submenus, and switching;;    between them in the update function of the top-level menu.;; Monday, October 9, 1995 Kotik: holding down CONTROL and choosing a file set;;    now lets you choose a file set command from a list.;;    See user-choose-file-set-command and support functions.;;    Commands include: Load Newer, Delete Fasls, Copy, Compare, List Changes,;;                      Search, Edit Definition, and Open Folder. ;; Thursday, October 5, 1995 Kotik: ignore errors in restore-fileset-menu;;    so applications built using file sets can be distributed without source code.;; Thursday September 14,1995 alanr: Shift key then select file set or ;;  subdirectory opens a search file dialog for files contained in dir:**;*.lisp;; Sunday August 20,1995 alanr: added variable *file-set-menu-ignore-directories* which is a list of named;;  which when encountered are ignored.;; Created: Thursday June 23,1994;; ;; ****************************************************************(in-package :ccl)(defvar *file-set-menu-ignore-directories* '("code" "substrate" "source"))  (assert (fboundp 'load-if-newer) ()         "This file should only be loaded as an adjunct to load-newer.lisp")(defvar *file-set-menu* nil)(defun lin-subdirectory-components (partial-path)  (loop for component in (pathname-directory partial-path)        unless (or (consp component) (keywordp component))        collect component));; patch menu-selected so that it is possible to have a submenu's \;; action function called(defun menu-selected (mi)  (let ((mob (menu-object (point-v mi))))    (if mob      (menu-select mob (point-h mi))      (let* ((quote-unselected-quote (menu-object (point-v (#_menuchoice))))             (choice (point-h (#_menuchoice)))             sub)        (when (and quote-unselected-quote (not (zerop choice)))          (setq sub (elt (slot-value quote-unselected-quote 'item-list) (1- choice)))          (when (and (typep sub 'submenu) (slot-value sub 'menu-item-action))            (menu-item-action sub)))))));; 10/16/95 Kotik: provide a slot to cache the menu items so we can switch back and forth;; between submenus that have commands and submenus with files/folders.(defclass fileset-menu (menu)   ((menu-items-cache :initform nil :accessor menu-items-cache)))(defclass submenu (fileset-menu)  ((menu-item-action :initarg :menu-item-action :initform nil)))(defmethod menu-item-action ((menu-item submenu))  (let ((action (slot-value menu-item 'menu-item-action)))    (when action (funcall action))))(defmethod sort-menus ((m menu))  (let* ((menu-items (copy-list (menu-items m)))        (sorted (sort (copy-list menu-items) 'string-lessp :key 'menu-item-title)))    (unless (equal menu-items sorted)      (apply 'remove-menu-items m menu-items)      (apply 'add-menu-items m sorted))    (loop for item in menu-items when (typep item 'menu) do (sort-menus item))));; 10/16/95 Kotik: Switch sub-menus in main menu to be the kind whose items are files/folders;;   (instead of commands) before adding submenus. Also, compute and cache the command menu for the file set(defmethod load-if-newer-menu-install ((fs file-set))  (let ((table (menu-item-table fs)))    (maybe-switch-subs-to-files (ensure-file-set-menu fs))    (get-command-menu-for-fileset fs)  ;; do this here so its cached    (update-mini-buffer-progress       (format nil "Updating menu for file set ~a" (name fs)))    (with-file-set-cache      (unless (file-set-loaded-this-time fs)        (let* ((mainmenu *file-set-menu*)               (filesetmenu (ensure-file-set-submenu fs mainmenu)))          (flet ((maybe (f)                    (unless (gethash (namestring f) table)                     (maybe-install-file-in-submenu fs filesetmenu f)                     (setf (gethash (namestring f) table) t))))            (iterate-over-files              fs             #'maybe             nil)))        (sort-menus *file-set-menu*)))))(defmethod load-if-newer-menu-install ((s string))  (load-if-newer-menu-install (file-set s)))(defmethod load-if-newer-menu-install ((s symbol))  (load-if-newer-menu-install (file-set s)))(defun lnm (ob)  (load-if-newer-menu-install ob))(defmethod load-if-newer :before ((f file-set) &rest args)  (declare (ignore args))  (load-if-newer-menu-install f))'(advise (:method load-if-newer (file-set))         (let ((f (car arglist)))          (load-if-newer-menu-install f)          (:do-it))        :when :around :name fileset-menu)  (defun option-key-p-now! ()  (key-down-p 58))(defun control-key-p-now! ()  (key-down-p 59))(defun shift-key-p-now! ()  (key-down-p 56))(defun command-key-p-now! ()  (key-down-p 55));; Sunday July 28,1996 alanr. Patched to handle new search files dialog(defun search-dialog-file-subset (dir)  #-ccl-3 (when *search-file-dialog* (window-close *search-file-dialog*))  #+ccl-3 (mapc 'window-close (windows :class 'search-file-dialog))  (setq %previous-search-file-file         (format nil "~a**;*.lisp" dir))  (let ((dialog (search-file-dialog)))    (when (find-class 'extended-search-files-dialog)      (set-dialog-item-text (view-named 'pathname dialog) (format nil "~a**;*.lisp" dir))      )));; 10/16/95 Kotik: took out control-key check, this is now done when you press on the menu header.;; 10/9/95 Kotik: if control key is pressed, user chooses fileset command from a menu.(defun edit-file-set-or-open-directory (fs)  (if (option-key-p-now!)    (open-directory-in-finder (back-translate-pathname (origin fs)))    (if (command-key-p-now!)      (eval-enqueue `(progn (format t "~&;Loading file set ~s~%" ,(name fs)) (load-if-newer ,(name fs))))      (if (shift-key-p-now!)        (search-dialog-file-subset (format nil "~a:" (name fs)))        (ed (back-translate-pathname (origin fs)))))))(defun dwim-filesetmenu-submenu (path)  (if (option-key-p-now!)    (open-directory-in-finder (back-translate-pathname path))    (if (control-key-p-now!)      (progn        (setq *last-choose-file-directory* (back-translate-pathname path))        (window-save-as (front-window)))      (if (shift-key-p-now!)        (search-dialog-file-subset (back-translate-pathname path))        (ed (back-translate-pathname path))))));; 10/16/95 Kotik: make the FileSets menu have an update function that switches the;;  per file set submenus between the ones whose items are commands, and the ones;;  whose items are files/folders, depending on whether control key is pressed.(defmethod ensure-file-set-menu ((fs file-set))  (if *file-set-menu*    (progn      (when (not (typep '*file-set-menu* 'fileset-menu))        (change-class *file-set-menu* 'fileset-menu)        *file-set-menu*))    (progn       (setq *file-set-menu*             (make-instance 'fileset-menu               :menu-title "FileSets"              :update-function                   #'(lambda (menu)                      (if (control-key-p-now!)                        (maybe-switch-subs-to-command-list menu)                        (maybe-switch-subs-to-files menu)))))      (set-menubar (append (menubar) (list *file-set-menu*)))      *file-set-menu*)))(defmethod ensure-file-set-submenu ((fs file-set) mainmenu)  (or (find (name fs) (menu-items mainmenu) :key 'menu-title :test 'string=)      (let ((it (make-instance                   'submenu :menu-title (name fs)                   :menu-item-action                   #'(lambda()                      (edit-file-set-or-open-directory fs)))))        (add-menu-items mainmenu it) it)));if (member (car current-dir) *file-set-menu-ignore-directories* :test 'string-equal)(defmethod maybe-install-file-in-submenu ((fs file-set) filesetmenu f)  (setq f (merge-pathnames ".lisp" f))  (let ((dirs (lin-subdirectory-components f))        (dirmenu filesetmenu))    (loop for dir in dirs          for current-dir = (list dir) then (nconc current-dir (list dir))          for sub =           (unless (member dir *file-set-menu-ignore-directories* :test 'string-equal)            (or (find dir (menu-items dirmenu) :key 'menu-title :test 'string=)                        (let ((it (make-instance                                     'submenu :menu-title dir                                     :menu-item-action                                     (let ((current-dir current-dir)                                          (f f))                                      #'(lambda()                                           (let ((dirpath                                                  (make-pathname                                                   :host (pathname-host f)                                                  :directory                                                   (cons :absolute current-dir))))                                            (dwim-filesetmenu-submenu dirpath)))))))                          (add-menu-items dirmenu it)                          it)))          do (setq dirmenu (or sub dirmenu)))    (let* ((filename (concatenate 'string (pathname-name f) "." (pathname-type f)))           (file-item (find filename (menu-items dirmenu) :key 'menu-item-title :test 'string=)))      (unless file-item        (add-menu-items dirmenu          (make-instance             'menu-item :menu-item-title filename :menu-item-action             #'(lambda () (ed f))))))));; 10/16/95 Kotik:;; If the menu-items of the submenu are not the file set commands, then;; cache the current menu-items and set the menu-items to be the commands.(defmethod maybe-switch-subs-to-command-list ((mainmenu fileset-menu))  (unless (eq mainmenu *file-set-menu*) (error "Not *file-set-menu*"))  (let* ((current-subs (menu-items mainmenu))         (subs-are-commands? (subs-are-commands? mainmenu)))    (unless subs-are-commands?      (without-interrupts       (setf (menu-items-cache mainmenu) (copy-list current-subs))       (apply #'remove-menu-items mainmenu current-subs)       (apply #'add-menu-items mainmenu               (mapcar #'(lambda (submenu)                          (get-command-menu-for-fileset (named-file-set (menu-title submenu))))                      current-subs))))));; 10/16/95 Kotik:;; If the menu-items of the submenu are the file set commands, then;; set the menu-items to be the cached sub items (the files and directories).(defmethod maybe-switch-subs-to-files ((mainmenu fileset-menu))  (unless (eq mainmenu *file-set-menu*) (error "Not *file-set-menu*"))  (let* ((current-subs (menu-items mainmenu))         (subs-are-commands? (subs-are-commands? mainmenu)))    (when subs-are-commands?      (without-interrupts       (apply #'remove-menu-items mainmenu current-subs)       (apply #'add-menu-items mainmenu (menu-items-cache mainmenu))))))(defmethod subs-are-commands? ((mainmenu fileset-menu))  (let ((items (menu-items mainmenu)))    (and items         (let ((sub-items (menu-items (car items))))           (and sub-items                (string= (menu-item-title (car sub-items))                         "Load If Newer"))))))(defvar *fileset-command-menu-alist* nil)(defun get-command-menu-for-fileset (fileset)  (let ((submenu-entry (assoc fileset *fileset-command-menu-alist*)))    (if submenu-entry      (cadr submenu-entry)      (let ((new-submenu (make-file-set-command-menu fileset)))        (push (list fileset new-submenu) *fileset-command-menu-alist*)        new-submenu))));; 10/16/95 Kotik: made it a DEFUN, the def-load-pointers is now at bottom of file.;; kotik: 10/5/95 - ignore errors so we can distribute MediaCalc without sources(defun restore-file-set-menu ()  (loop for preloaded in (mapcar 'name (all (class-prototype (find-class 'file-set))))        do        (when (or (not *file-set-menu*)                  (not (find preloaded (menu-items *file-set-menu*) :key 'menu-item-title)))          (let ((fs (ignore-errors (file-set preloaded))))            (if fs               (load-if-newer-menu-install fs)              (format t "~%Unable to restore file set ~A" preloaded))))));; 10/16/95 Kotik: for debugging(defun redo-fileset-menu ()  (menu-deinstall *file-set-menu*)  (setq *file-set-menu* nil)  (setq *fileset-command-menu-alist* nil)  (restore-file-set-menu));; 10/16/95 Kotik: Creates a submenu for a fileset with commands on that file set.;;   You get this submenu if you hold down control before pressing on the FileSets menu header.(defun make-file-set-command-menu (fs)  (let ((submenu (make-instance 'menu :menu-title (name fs))))    (flet ((make-file-set-command-menu-item (com)             (let* ((function-spec `(lambda () (,(second com) ,fs)))                    (fn (eval `(function ,function-spec))))               ;; added by the society to eradicate anonymous functions Wednesday January 3,1996               (lfun-name fn `(,(second com) :in make-file-set-command-menu))               (make-instance 'menu-item :menu-item-title (car com) :menu-item-action fn))))      (apply #'add-menu-items submenu             (mapcar #'make-file-set-command-menu-item                     ;; NOTE: if you change the first element of this list,                      ;; you must update function subs-are-commands? above.                     ;; 10/16/95 Kotik                     `(("Load If Newer"   load-if-newer-interactive)                       ("Delete Fasls..." delete-fasls-interactive)                       ("Copy..."         copy-file-set-interactive)                       ("Compare..."      compare-file-sets-interactive)                       ("List Files Newer Than..."  list-modified-file-set-files-interactive)                       ("Describe"        describe-file-set-interactive)                       ("Search Files..." search-file-set-files-interactive)                       ("Edit Definition" edit-file-set-definition-interactive)                       ("Open Folder"     open-file-set-home-folder-interactive))))      submenu)))(defmethod load-if-newer-interactive ((fs file-set))  (eval-enqueue    `(progn (format t "~&; Loading file set ~S" ,(name fs))           (load-if-newer ,(name fs)))))(defmethod delete-fasls-interactive ((fs file-set))  (when (y-or-n-dialog (format nil "Delete fasl files in fileset ~S~@                                    and all subordinate filesets?" (name fs)))    (eval-enqueue     `(progn        (format t "~&; Deleting fasl files in file set ~s" ,(name fs))        (delete-fasls ,fs :recursive? t)))))(defmethod copy-file-set-interactive ((fs file-set))  (let ((doc-types (select-item-from-list                     (file-set-document-types fs)                    :window-title "Choose Document Types to Copy"                    :selection-type :disjoint))        (copy-to-dir (choose-new-directory-dialog :prompt "Folder to Copy To:"                                                  :button-string "Copy")))    (eval-enqueue     `(copy-file-set ,fs ,copy-to-dir :document-types ',doc-types :recursive? t))))(defmethod compare-file-sets-interactive ((fs1 file-set))  (let ((fs2 (choose-file-set  :prompt (format nil "Choose File Set to Compare to ~S" (name fs1)))))    (eval-enqueue     `(progn        (format t "~&; Comparing file sets ~S and ~s" ,(name fs1) ,(name fs2))        (compare-filesets ,(name fs1) ,(name fs2) :print-diffs t)))));; 10/19/95 Kotik: print the modified files and their write dates(defmethod list-modified-file-set-files-interactive ((fs file-set))  (let* ((current-date-string            (multiple-value-bind (second minute hour date month year ignore)                        (decode-universal-time (get-universal-time))                    (declare (ignore ignore))             (format nil "~d/~d/~d ~2,'0d:~2,'0d:~2,'0d" month date (rem year 100) hour minute second)))         (document-types (select-item-from-list (sort (file-set-document-types fs :recursive? t)                                                      #'string-lessp)                                   :window-title "Choose Document Types to List"                                   :table-print-function #'(lambda (sym stream)                                                             (format stream "~A"                                                                      (substitute #\  #\- (string-capitalize sym))))                                   :selection-type :disjoint))         (after-date (get-string-from-user                        (format nil "List files modified after date:")                       :initial-string current-date-string                       :ok-text "Go"))         (after-universal-time (parse-mm-dd-yy-hh-mm-ss-time after-date)))    (eval-enqueue      `(progn        (format t "~&; Finding files in file set ~s modified since ~A ..." ,(name fs) ,after-date)        (let ((files (files-modified-after ,fs ,after-universal-time :document-types ',document-types)))          (format t "~&~D files in fileset ~s modified since ~A:"                   (length files) ,(name fs) ,after-date)          (loop for f in files  do (format t "~&~A  ~S" (date (cdr f)) (car f))))))))(defmethod describe-file-set-interactive ((fs file-set))  (eval-enqueue    `(progn (format t "~&Describe file set not implemented yet."))))(defmethod search-file-set-files-interactive ((fs file-set))  (eval-enqueue    `(search-dialog-file-subset (format nil "~a:" ,(name fs)))))(defmethod edit-file-set-definition-interactive  ((fs file-set))  (eval-enqueue    `(ed (back-translate-pathname (origin ,fs)))))(defmethod open-file-set-home-folder-interactive ((fs file-set))  (eval-enqueue    `(open-directory-in-finder (back-translate-pathname (origin ,fs)))));; 10/19/95 Kotik: return a list of conses (file . write-date) sorted with most recent changes first.;; 10/10/95 Kotik: New. Date can be a universal time or a date string of form "mm/dd/yy hh:mm:ss";; where everything after the yy is optional(defmethod files-modified-after ((fs file-set) date &key (document-types :all) (recursive? t))  (let ((after-universal-time (cond ((integerp date) date)                                    ((stringp date) (parse-mm-dd-yy-hh-mm-ss-time date))                                    (t (error "Bad date ~S." date))))        (files nil))    (labels ((find-file-set-files-modified-after (file-set after-time)               (map-file-set-files file-set                                    #'(lambda (f)                                       (let ((write-date (file-write-date f)))                                         (when (and (> write-date after-universal-time)                                                    (not (string= "fasl" (pathname-type f))))                                           (push (cons f write-date) files))))                                   :document-types document-types                                   :file-set-function                                    (if recursive?                                      #'(lambda (fs)                                          (find-file-set-files-modified-after fs after-time))                                     nil))))      (if (stringp after-universal-time)        (message-dialog (format nil "Bad date specification ~A.~%~A"                                 date after-universal-time))        (progn (find-file-set-files-modified-after fs after-universal-time)               (sort files #'(lambda (f1 f2) (> (cdr f1) (cdr f2)))))))));; 10/10/95 Kotik:(defmethod files-modified-after ((str string) date &key (document-types :all) (recursive? t))  (let ((fs (named-file-set str)))    (if fs       (files-modified-after fs date :document-types document-types :recursive? recursive?)      (format t "~&FILES-MODIFIED-AFTER: no fileset named ~S" str))));; 10/10/95 Kotik: this either returns a Universal Time or an error string.(defun parse-mm-dd-yy-hh-mm-ss-time (time-str)  (setq time-str  (substitute-if #\     ; substitute spaces for slashes and colons                                 #'(lambda (ch) (member ch '(#\: #\/ #\\ #\|) :test 'char=))                                 time-str))  (let ((month 0) (date 0) (year 0) (hour 0) (minute 0) (second 0)        (numbers nil)        (eof-value :eof)        (at-end-of-string? nil)        (bad-time-spec? nil)        (pos 0))    (while (not at-end-of-string?)      (multiple-value-bind (number new-pos)                           (read-from-string time-str nil eof-value :start pos)        (if (and (symbolp number) (eq number :eof))          (setq at-end-of-string? t)          (progn (push number numbers) (setq pos new-pos)))))    (setq numbers (nreverse numbers))    (when (< (length numbers) 3)      (setq bad-time-spec? (format nil "~%You need to specify at least month, day, and year.")))    (macrolet ((do-next-number (index sym lower-bound upper-bound)                 `(when (and (< ,index (length numbers)) (not bad-time-spec?)                    (setq ,sym (nth ,index numbers))                          (unless (and (integerp ,sym) (>= ,sym ,lower-bound) (<= ,sym ,upper-bound))                      (setq bad-time-spec?                             (format nil "Bad ~s ~A in date ~S: ~s must be a number from ~d to ~d"                                     ',sym ,sym time-str ',sym ,lower-bound ,upper-bound)))))))      (do-next-number 0 month 1 12)      (do-next-number 1 date 1 31)      (do-next-number 2 year 0 99)      (do-next-number 3 hour 0 23)      (do-next-number 4 minute 0 59)      (do-next-number 5 second 0 59)      (if bad-time-spec?  ;; return the error message if the time spec was malformed        bad-time-spec?        (encode-universal-time second minute hour date month year)))))    ;; 10/10/95 Kotik:; if choose-type = :single, returns a single file set, otherwise returns a list.(defun choose-file-set (&key (file-sets nil)                                 (prompt "Choose Fileset")                                (choose-type :single))  (unless file-sets     (setq file-sets           (let ((fs-names (remove-duplicates                            (mapcar 'name (all (class-prototype (find-class 'file-set))))                           :test 'string=)))            (mapcar 'named-file-set (sort fs-names #'(lambda (f1 f2)                                                  (string<= (string-downcase f1)                                                           (string-downcase f2))))))))  (let ((choice (select-item-from-list file-sets                              :window-title prompt                              :selection-type (if (eq choose-type :single)                                                :single :disjoint)                              :table-print-function                              #'(lambda (fs stream) (format stream "~A" (name fs))))))    (if (eq choose-type :single)      (car choice)      choice)))  ;; 10/10/95 Kotik: returns the list of document types in a file set(defmethod file-set-document-types ((fs file-set) &key (recursive? t))  (unless (eq (class-name (class-of fs)) 'file-set)    (error "~S is not a fileset" fs))  (let ((doc-types* (list :lisp-source :lisp-binary))        (files (files fs)))    (declare (special doc-types*))    (loop for file in files do          (when (consp file)            (if (string= (car file) "FILE-SET")              (when recursive?                (let* ((sub-fs (file-set (second file)))                       (sub-fs-doc-types (file-set-document-types sub-fs :recursive? t)))                  (setq doc-types*                         (remove-duplicates (append doc-types* sub-fs-doc-types)))))              (let ((doc-type (getf (cdr file) :document-type)))                (when doc-type (pushnew doc-type doc-types*))))))    doc-types*));; 10/16/95 Kotik: do this last so we don't get any undefined function errors;;   while loading this file during system build.(def-load-pointers restore-the-file-set-menu ()  (restore-file-set-menu)  ) 