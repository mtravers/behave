;; ****************************************************************;;  Other file types, require;; (in-package :ccl);; Monday April 3,1995: There should be some way to say that a particular file needs to be available at load time,;; so that if we distribute a world, if those files are not present they are either re-created, or;; warned about. e.g streamview resource files, and brians ".a" files.'(make-instance 'file-set  :define-logical-host? t  :name "fileset"  :run-time-files '("resources:foo")             <-----  :files  '("finder-interact"    ";cinfopbrec"    ";fast-find"    ";load-newer"     ";file-set-menu"    ";file-set-edit-file"    ";compare-file-sets"    ));; ****************************************************************;;;; Author: Alan Ruttenberg, MIT Media Lab;; email:  alanr@media.mit.edu;; Thursday August 22,1996 alanr: Redefinitions of methods where argument lisp has changed, no longer go into;;   the debugger. Instead the change is made after writing a comment to the listener.;; Wednesday June 5,1996 alanr: Clean up mini-buffer writing code.;; Friday May 24,1996 alanr: Add do-before and do-after slot which are evaled before and after the load of the file-set;; Dec 30/1995: alanr. Don't output to mini-buffer if there is no *top-listener* (as in ccl3 somtimes);; Saturday December 9,1995. Show file name in minibuffer *before* loading it. Show status when finding file set";; 12/5/95 Kotik: make map-file-set-files map over the file set definition file.;; Monday December 4,1995 alanr: remove old definitions of file set before pushing new in initialize-instance;; 10/31/95 Kotik: fix a bug in LOGICAL-PATHNAME-DIRECTORY;; Monday, Oct 9, 1995 Gordon Kotik: fixed a misleading message in delete-fasls for pathnames.;; Thursday, Oct 5, 1995 Gordon Kotik: new defvar *load-newer-filesets-on-restart?* controls;;   whether file sets are automatically reloaded at restart.  The variable is checked;;   in macro when-restart-load-newer.;; Wednesday Sept 27, 1995 Gordon Kotik - changed find-file-set-using-search-path-path to;;    call to DIRECTORY with keyword arg RESOLVE-ALIASES set to :SHOW-ALIAS.  ;;    This causes DIRECTORY to expand aliases to folders during the search,;;    but return any matching pathnames using the pathname through the alias.;; Monday Sept 25, 1995  Gordon Kotik - changed load-relative-logical-host to not set up hard-wired;;       pathname translations for .A files;; Wednesday Sept 20, 1995 Gordon Kotik - changed code to not require that there be a logical host "projects".;;      To do this, I changed the initialization of *cache-project-file-sets?* to NIL and;;      changed the initialization of *file-set-search-path* to NIL;; Friday August 25,1995 alanr. Missed a couple of places where I needed to use get-mac-time instead of get-universal-time.;; Wednesday August 23,1995. Switched from universal time to mac-time since conversion was costly. I update any existing;;  load-files when this loads.;; Thursday July 27,1995 ln now eval-enqueues the load.;; Thursday June 1,1995 Turned egc off for loading .lisp files too.;; Wednesday April 5,1995: made search on file-set-search-path use fast-find-file when a whole volume is given;;                          such as "macintosh HD:**:";; Saturday April 1,1995 turns off egc while loading fasl files. Mostly creating new long lived structure.;;                       save 23 seconds out of 80.;; Saturday April 1,1995 added *cached-projects-file-sets?* to say whether to keep a list of file sets on;;   directory-below projects. ;; Thursday March 23,1995 : removed (wild-pathname-p foo) and used cheap-wild-pathname-p = (%path-mem "*" foo) ;; Thursday March 23,1995  update-binaries now pays attention to file-set-cache;; Wednesday March 22,1995 : alanr starting cleanup.;; Wednesday December 28,1994 moved restart-case from :around method so that it didn't conflict;;                            with load-if-newer-menu-install;; Monday December 19,1994 added quick check to see if we need to load. Also, only update menu if;;                         files have been added or taken away. Combined speedup is a factor of 2;; Monday May 3,1993 0:02am Added caching of file write times and dates, and faster checks for existing;;                          file set placement;; Tuesday November 10,1992 4:18pm ;;  patch to have ";foo" be equal to prepending the logical pathname of the file set to the front;;;; Created: Saturday February 2,1991;; ;; ****************************************************************(export 'load-if-newer)(defvar *file-sets-cache* nil)(defvar *loaded-this-time-file-sets* nil)(defvar *loading-file-set-logical-host* nil)(defvar *file-set-search-common-disks?* nil)(defparameter *fasl-suffix* (if (find :powerpc *features*) ".pfsl" ".fasl"))(defparameter *load-file-set-verbose* nil);; GBK 9/20/95 - changed initialization of *cache-projects-file-sets?* from T to NIL because;; we don't want to require the user to have a logical host named "projects" to use File Set(defvar *cache-projects-file-sets?* nil)(defvar *cached-projects-file-sets* nil)(defvar *add-loaded-file-set-paths-to-search-path?* nil); bind to t while you don't want to load a file set more than once; Effectively the same as with-file-set-cache but that macro may not be defined yet in init file.(defvar *loading-multiple-file-sets* nil)#|;; unfortunately this never worked well because it is ahard to figure out when;; one is "initializing" in general.(defvar *loading-at-initialization* nil)(defvar *initialization-loaded-file-sets* nil)(defun reset-*loading-at-initialization* ()  (setq *loading-at-initialization* t)  (setq *initialization-loaded-file-sets* nil))(pushnew 'reset-*loading-at-initialization* *lisp-cleanup-functions*)(pushnew 'reset-*loading-at-initialization* *lisp-startup-functions*)(def-load-pointers *loading-at-initialization* ()  (advise print-listener-prompt     (progn      (unadvise print-listener-prompt :when :before :name *loading-at-initialization*)      (setq *loading-at-initialization* nil)      (setq *initialization-loaded-file-sets* nil))    :when :before    :name *loading-at-initialization*))|#(def-load-pointers projects-cache ()   (when *cache-projects-file-sets?* (setq *cached-projects-file-sets* (directory "projects:*;*-file-set.lisp"))))(defun volume-refnum (vol)  (unless (char= (char vol (1- (length vol))) #\:)    (setq vol (format nil "~a:" vol)))  (%stack-iopb (pb np)     (%path-to-iopb vol pb)     (%get-signed-word pb $iovrefnum)))(defmacro with-file-set-cache (&body body)  `(let ((*file-sets-cache* (or *file-sets-cache* (make-hash-table :test 'equal)))         (*loaded-this-time-file-sets* (or *loaded-this-time-file-sets* (make-hash-table))))     (flet ((loading-file-set (f)              (setf (gethash f *loaded-this-time-file-sets*) t))            (file-set-loaded-this-time (f)              (gethash f *loaded-this-time-file-sets*))            (file-set-didnt-load (f)              (setf (gethash f *loaded-this-time-file-sets*) nil))              )       ,@body)))(defmacro cheap-wild-pathname-p (arg)  `(%path-mem "*" ,arg))(defun path-inside-directory? (directory path)  (let ((directory (ignore-errors (namestring (translate-logical-pathname directory))))        (path (ignore-errors (namestring (translate-logical-pathname path)))))    (and directory path (equalp (pathname-host path) (pathname-host directory))         (let ((dir-dir-components (pathname-directory directory))               (path-dir-components (pathname-directory path)))           (and (>= (length path-dir-components) (length dir-dir-components))                (equalp dir-dir-components                        (subseq path-dir-components 0 (length dir-dir-components))))))))(defvar *fast-probe-cache* nil)(defun fast-probe-file (file-truename)  (if (null file-truename)     nil    (if *fast-probe-cache*       (case (gethash file-truename *fast-probe-cache*)        (:missing nil)        ((nil)          (cache-directory-info  file-truename)         (if (gethash file-truename *fast-probe-cache*)           file-truename           (progn (setf (gethash file-truename *fast-probe-cache*) :missing) nil)))        (otherwise file-truename))      (probe-file file-truename))))(defun mac-file-write-date (path)  (%stack-iopb (pb np)    (%path-to-iopb path pb :errchk)    (+ (ash (%get-unsigned-word pb $ioFlMdDat) 16) (%get-unsigned-word pb (+ 2 $ioFlMdDat)))))(defun get-mac-time ()  (+ (ash (%get-unsigned-word (%int-to-ptr $Time)) 16)     (%get-unsigned-word (%int-to-ptr $Time) 2)))(defun fast-file-write-date (file-truename)  (if *fast-probe-cache*     (case (gethash file-truename *fast-probe-cache*)      (:missing (mac-file-write-date file-truename))      ((nil) (cache-directory-info (namestring (make-pathname :directory (pathname-directory file-truename))))       (if (gethash file-truename *fast-probe-cache*)         (progn (setf (gethash file-truename *fast-probe-cache*) :missing) (mac-file-write-date file-truename))         (gethash file-truename *fast-probe-cache*)))      (otherwise (gethash file-truename *fast-probe-cache*)))    (mac-file-write-date file-truename)))(defmacro with-fast-file-probe-and-time (&body body)  `(let ((*fast-probe-cache* (or *fast-probe-cache* (make-hash-table :test 'equalp))))     ;; values in hash table are :missing or modification date     ;; 1. Check truename in hash     ;; 2. If missing return nil to probe-file error for modification time     ;; 3. if nil cache the directory and retry     ;; 4. otherwise use usual     ,@body))(defun fast-cache-file (truename time)  (when *fast-probe-cache*    (setf (gethash truename *fast-probe-cache*) time)))(defun cache-directory-info (directory)  (rlet ((filename :str255)          (fpb :cinfopbrec))    (let* ((volid (volume-refnum (second (pathname-directory directory))))           (dirid (%stack-iopb (pb np)                    (%path-to-iopb directory pb)                    #-powerpc(#_pbopenwd pb) #+powerpc(#_pbopenwdsync pb)                    (prog1                      (rref pb wdpbrec.iowddirid)                       #-powerpc (#_pbclosewd pb) #+powerpc (#_pbclosewdsync pb)))))      (setf (rref fpb cinfopbrec.ioVrefnum) volid)      (setf (rref fpb cinfopbrec.ionameptr) filename)      (loop for count from 1            for res = (progn                         (setf (rref fpb cinfopbrec.iodirid) dirid)                        (setf (rref fpb cinfopbrec.iofdirindex) count)                        #-powerpc (#_pbgetcatinfo fpb) #+powerpc (#_pbgetcatinfosync fpb))            until (not (zerop res))            do            (unless (logbitp 4 (rref fpb cinfopbrec.ioflattrib))              (let ((modificationtime (+ (ash (%get-unsigned-word fpb $ioFlMdDat) 16) (%get-unsigned-word fpb (+ 2 $ioFlMdDat))))                    (fname (%get-string filename)))                (setf (gethash (namestring (merge-pathnames fname directory)) *fast-probe-cache*) modificationtime)))))))(defclass load-file ()   ((all :initarg :all :initform nil :accessor all :allocation :class)   (source-name :initarg :source-name :initform nil :accessor source-name)   (source-truename :initarg :source-truename :initform nil :accessor source-truename)   (binary-name :initarg :binary-name :initform nil :accessor binary-name)   (binary-truename :initarg :binary-truename :initform nil :accessor binary-truename)   (loaded-time :initarg :loaded-time :initform 0 :accessor loaded-time)   (loaded-source? :initarg :loaded-source? :initform nil :accessor loaded-source?)   (never-compile? :initarg :never-compile? :initform nil :accessor never-compile?)   ))(defun loaded-files (&aux them)  (maphash #'(lambda(key data) (declare (ignore key))(push data them)) *all-load-files-by-pathname*)  (nreverse them))(defun update-all ()  (with-file-set-cache    (with-fast-file-probe-and-time      (dolist (f (reverse (loaded-files)))        (setf (loaded-source? f) t)        (update-binary f)))))(defmethod initialize-instance :after ((f load-file) &key)   (setf (source-name f) (namestring (merge-pathnames ".lisp" (source-name f)))         (source-truename f) (namestring (translate-logical-pathname (source-name f)))         (binary-name f) (namestring (merge-pathnames *fasl-suffix* (pathname (source-name f))))         (binary-truename f) (namestring (translate-logical-pathname (binary-name f))))   (push f (all f)))  (defmethod print-object ((f load-file) stream)  (format stream "#<load-file ~S {~a})~A>"           (pathname-name (source-name f))          (namestring (make-pathname :directory (pathname-directory (source-name f))))          (if (plusp (loaded-time f))            ""            " - never loaded")))                         ;; Tuesday December 31,1996 added this for faster lookup with extended meta-point.(defvar *all-load-files-by-name* (make-hash-table :test 'equalp))(defvar *all-load-files-by-pathname* (make-hash-table :test 'equalp))(defun make-load-file (name &rest args)  (let ((source-name (merge-pathnames #.(make-pathname :type "lisp") name)))    (pushnew source-name (gethash (pathname-name source-name) *all-load-files-by-name*)             :test #'(lambda(a b) (equalp (namestring a) (namestring b))))    (setq source-name (namestring source-name))    (or (gethash source-name *all-load-files-by-pathname*)        (setf (gethash source-name *all-load-files-by-pathname*)              (apply 'make-instance 'load-file :source-name source-name args)))    ))  #|  ;; ought to change this to a hash table too, but I don't want to worry about where else the  ;; assumption is made.  (let ((all (all (class-prototype (find-class 'load-file)))))    (or      (find-if #'(lambda(b) (string-equal source-name (source-name b))) all)     (apply 'make-instance 'load-file :source-name source-name args)     ))))(defun make-load-file (name &rest args)  (let ((source-name (merge-pathnames #.(make-pathname :type "lisp") name)))    (setq source-name (namestring source-name))    (let ((all (all (class-prototype (find-class 'load-file)))))      (or        (find-if #'(lambda(b) (string-equal source-name (source-name b))) all)       (apply 'make-instance 'load-file :source-name source-name args)       ))))|#(defmacro without-egc (&body body)  (let ((egc? (make-symbol "EGC?")))    `(let ((,egc? (egc-active-p)))       (unwind-protect (progn (when ,egc? (egc nil)) ,@body)         (when ,egc? (egc t))))))  (defmethod load-source ((f load-file))  (without-egc    (load (source-name f))    (setf (loaded-source? f) t)    (setf (loaded-time f) (mac-file-write-date (source-name f)))));; Thursday April 27,1995 mt patch. Is this correct?(defmethod update-binary ((path pathname))  (let ((lf (make-load-file (namestring path))))    (setf (slot-value lf 'loaded-source?) t)    (update-binary lf)))(defmethod update-binary ((f load-file))  (unless (never-compile? f)    (with-slots (source-name binary-name source-truename binary-truename loaded-source?) f      (when loaded-source?        (let* ((source-exists (or (fast-probe-file source-truename))) ; (probe-file source-name))) Tuesday August 22,1995 with bw               (binary-exists (or (fast-probe-file binary-truename))) ; (probe-file binary-name)))               (source-time (and source-exists                                  (if (eq source-exists source-truename)                                   (fast-file-write-date source-truename)                                   (mac-file-write-date source-name))))               (binary-time (and binary-exists                                  (if (eq binary-exists binary-truename)                                   (fast-file-write-date binary-truename)                                   (mac-file-write-date binary-name))))               (binary-up-to-date (and binary-exists source-exists (> binary-time source-time))))          (when (and source-exists (not binary-up-to-date))            (maybe-create-directory binary-name)            (compile-file (source-name f) :output-file (binary-name f) :verbose t)            (fast-cache-file (binary-truename f) (get-universal-time))            (setf (loaded-time f) (get-mac-time))))))))(defun maybe-create-directory (path)  (let ((directory (make-pathname :directory (pathname-directory path) :host (pathname-host path))))    (unless (probe-file directory)      (format t "~&;; Creating directory ~A" directory)      (ccl::create-directory directory))))(defmethod load-binary ((f load-file))  (let ((egc? (egc-active-p)))    (unwind-protect (progn (when egc? (egc nil)) (load (binary-name f)))      (when egc? (egc t))))  (setf (loaded-source? f) nil)  (setf (loaded-time f) (mac-file-write-date (binary-name f))))(defmethod warn-loaded-once-but-cant-now ((f load-file))  nil)(defmethod warn-cant-load ((f load-file))  (warn "~s has never been loaded, and no source or binary for it can be found to load it now"         (source-name f)))(defmethod dont-need-to-load? ((f load-file))  (with-slots (source-name loaded-time loaded-source?) f    (and loaded-source?         (when (plusp loaded-time) ; we have been loaded in the past           (let ((source-modified-time (or (ignore-errors (mac-file-write-date source-name)) -1)))             (<= source-modified-time loaded-time))))))(defmethod load-if-newer ((f load-file)  &key load-source-invalidates)  (unless (dont-need-to-load? f)    (with-slots (source-name binary-name source-truename binary-truename never-compile?) f      (let* ((source-exists (or (fast-probe-file source-truename))) ;  (probe-file source-name)))Tuesday August 22,1995 with bw             (binary-exists (and (not never-compile?)                                 (or (fast-probe-file binary-truename) (probe-file binary-name))))             (source-time               (and source-exists                    (if (eq source-exists source-truename)                     (fast-file-write-date source-truename)                     (mac-file-write-date source-name))))             (binary-time               (and binary-exists                    (if (eq binary-exists binary-truename)                     (fast-file-write-date binary-truename)                     (mac-file-write-date binary-name))))             (binary-up-to-date (and binary-exists source-exists (> binary-time source-time)))             (loaded-time (or (loaded-time f) 0)))        (cond                   ;; trying to get the invalidate-source logic right.         ;((and binary-truename (not binary-exists)         ;                    source-exists (< source-time loaded-time))          ;               (load-source f))                  ((and binary-exists (not source-exists) (> binary-time loaded-time))          (load-binary f))         ((and binary-up-to-date (> binary-time loaded-time))          (load-binary f))         ((and source-exists (> source-time loaded-time))          (load-source f)          (loop for file in load-source-invalidates                do (invalidate-source file)))         ((and binary-exists (> binary-time loaded-time))          (load-binary f))         ((and (plusp loaded-time) (not (or source-exists binary-exists)))          (warn-loaded-once-but-cant-now f))         ((and (zerop loaded-time) (not (or source-exists binary-exists)))          (warn-cant-load f)))))    f))(defmethod invalidate-source ((file string))  (if (or (cheap-wild-pathname-p file) (pathname-directory file) (neq (pathname-host file) :unspecific))    (invalidate-source (pathname file))    (invalidate-source (file-set file))))(defmethod invalidate-source ((f load-file))  (invalidate-source (source-name f)));; should delete binary, then on loading, if binary has been loaded and is now missing,;; then load the source.(defmethod invalidate-source ((file pathname))  (loop for fasl in (directory (merge-pathnames *fasl-suffix* file))        do (delete-file fasl)));        (set-file-write-date path (get-universal-time))))(defvar *null-ostype* (intern (coerce (vector #\null #\null #\null #\null) 'string) 'keyword));; 10/31/95 Kotik: preserve the name AND the type of the truenames, not just the name.(defun logical-pathname-directory (directory)  (let ((truenames (directory directory) ))    ;; get rid of system created files.    (setq truenames (remove-if #'(lambda(f) (and (eq (mac-file-type f) *null-ostype*)                                                  (eq (mac-file-creator f) *null-ostype*)))                               truenames))    (mapcar #'(lambda(truename) (merge-pathnames (make-pathname :name (pathname-name truename)                                                                :type (pathname-type truename)) ;; 10/31/95 Kotik                                                 directory))            truenames)))(defun load-if-newer-directory (directory)  (mapcar 'load-if-newer           (sort (union (logical-pathname-directory (merge-pathnames ".lisp" directory))                       (logical-pathname-directory (merge-pathnames *fasl-suffix* directory))                       :test 'equalp)                 #'string-lessp :key #'namestring)))(defmethod load-if-newer ((name string) &rest args &key load-source-invalidates (document-type :lisp-source))  "Use conventions: Source files need to have .lisp extensions, binary .fasl"  (declare (ignore load-source-invalidates document-type))    (with-file-set-cache    (let ((host (pathname-host name)))      (if (and (null (pathname-directory name)) (or (eq host :unspecific)                                                    (and (null host)                                                         (not (or (find #\: host) (find #\; host))))))        (apply 'load-if-newer (file-set name) args)        (apply 'load-if-newer (make-load-file name) args)))))(defmethod load-if-newer ((name symbol) &rest args)  (apply #'load-if-newer (string-downcase (string name)) args))(defmethod load-if-newer ((path pathname) &rest args &key load-source-invalidates (document-type :lisp-source))  "Use conventions: Source files need to have .lisp extensions, binary .fasl"  (declare (ignore load-source-invalidates document-type))  (apply 'load-if-newer (make-load-file (namestring path)) args))(defmethod source-name ((name string))  (source-name (make-load-file name)))(defmethod source-name ((path pathname))  (load-if-newer (make-load-file (namestring path))))(eval-when (:load-toplevel)  (and ccl::*loading-file-source-file*       (setf (loaded-time (make-load-file ccl::*loading-file-source-file*))             (get-mac-time))))(defclass file-set ()  ((name :initarg :name :initform nil :accessor name)   (files :initarg :files :initform nil :accessor files)   (origin :initarg :origin :initform nil :accessor origin)   (all :initarg :all :initform nil :accessor all :allocation :class)   (menu-item-table :initarg :menu-item-table :initform (make-hash-table :test 'equalp) :accessor menu-item-table)   (do-before :initarg :do-before :initform nil :accessor do-before)   (do-after :initarg :do-after :initform nil :accessor do-after)   (update-binary-when :initarg :update-binary-when :initform :after :accessor update-binary-when)   ; Saturday November 23,1996 alanr   (file-set-shared-libraries :initarg :shared-libraries :initform nil :accessor file-set-shared-libraries))  (:default-initargs :allow-other-keys t))(defun ensure-interface-installed (paths)  (when (null paths) (return-from ensure-interface-installed))  (when (not (consp paths)) (setq paths (list paths)))  (flet ((reindex (files)           #+ccl-3 (declare (ignore files))           (format t "~&;;; Reindexing interfaces to include ~a~&" (mapcar 'pathname-name paths))           (format t "~&;;; This will only happen once...~&")           (reindex-interfaces #-ccl-3 :files #-ccl-3 files)))    (let (something?)      (loop for rawpath in paths            for path = (merge-pathnames rawpath ".lisp")          do          (let ((interface-path (merge-pathnames (pathname-name path) "ccl:interfaces;.lisp")))            (multiple-value-bind (exists? error?) (ignore-errors (probe-file interface-path))              (when (and (not error?)                          (or (not exists?)                             (< (mac-file-write-date interface-path) (mac-file-write-date path))))                (when                  (y-or-n-dialog (format nil "I need to install a current version of the interface file ~s. Is that ok. This should happen only once. Following installation, The interfaces will be reindexed."                                          (pathname-name interface-path))                                 :size #@(300 200)                                 :yes-text "OK")                  (format t "~&;;; Copying ~a into \"ccl:interfaces;\" to bring them up to date"                          (namestring path))                  (copy-file path interface-path :if-exists :supersede)                  (push interface-path something?)                  )))))      (when something? (reindex something?)))))(defmethod initialize-instance ((f file-set) &key (define-logical-host? t) interface-files)  (call-next-method)  (setf (all f) (delete (name f) (all f) :key 'name :test 'equalp))  (push f (all f))  (when define-logical-host?    (load-relative-logical-host (name f)))  (ensure-interface-installed    (loop for path in interface-files append (resolve-pathname-spec f path))))(defun named-file-set (name)  (find name (all (class-prototype (find-class 'file-set))) :key 'name :test 'equalp))(defmethod print-object ((f file-set) stream)  (print-unreadable-object (f stream :identity t)    (format stream "file set ~s" (name f))))(defmethod resolve-pathname-spec ((fs file-set) spec)  (when (and (stringp spec) (char= (char spec 0) #\;))    (setq spec (format nil "~a:~a" (name fs) (subseq spec 1))))  (if (cheap-wild-pathname-p spec)    (logical-pathname-directory spec)    (list spec)));; Thursday April 25,1996 alanr: Removed probe-file test that gordon inserted. Factor of 10 slowdown with it.;; 4/24/96 Kotik: fix bug where it got an error when a file was not found;; 12/5/95 Kotik: make it map over the file set definition file if :document-types is :all;; or if it's a list that contains :file-set-definition(defmethod map-file-set-files ((fs file-set) function                                   &key                                   (document-types :all)                                  (file-set-function nil)                                  (call-with-keywords? nil))  (let* ((dont-call-on-lisp-file (and (not (atom document-types))                                      (member :lisp-binary document-types)                                      (not (member :lisp-source document-types))))         (file-set-definition-file (format nil ";~A-file-set.lisp" (name fs)))         (file-set-definition-file-spec (list file-set-definition-file :document-type :file-set-definition)))    (when dont-call-on-lisp-file (push :lisp-source document-types))    (flet ((lisp/fasl-function-filter (file &rest args)             (let ((lisp-source? (eq (getf args :document-type :lisp-source) :lisp-source)))               (when (and lisp-source? (null (pathname-type file)))                 (setq file (namestring (merge-pathnames ".lisp" file))))               ;(if nil ;(not (probe-file file))                ; (format t "~&;  WARNING! File not found: ~a"  file)                 (cond (lisp-source?                         (unless dont-call-on-lisp-file (apply function file (and call-with-keywords? args)))                        (when (and (or (eq document-types :all)                                       (member :lisp-binary document-types)))                          (apply function (namestring (merge-pathnames *fasl-suffix* file)) (and call-with-keywords? args))))                       (t (apply function file (and call-with-keywords? args))))                 ))           ;)           (assure-directory (f)             (if (and (stringp f) (char= (char f 0) #\;))               (format nil "~a:~a" (name fs) (subseq f 1))               f)))      (loop for f in (cons file-set-definition-file-spec (files fs))            do            (if (not (consp f))              (if (or (find #\: f) (find #\; f))                (when (or (eq document-types :all)                           (member :lisp-source document-types))                  (progn                    (setq f (assure-directory f))                    (if (cheap-wild-pathname-p f)                      (and function (mapc #'lisp/fasl-function-filter (logical-pathname-directory f)))                      (and function (funcall #'lisp/fasl-function-filter f)))))                (when file-set-function                   (when file-set-function (funcall file-set-function (file-set f)))))              (if (string-equal (car f) "FILE-SET")                (when (and file-set-function (neq file-set-function nil))                  ; Friday October 4,1996 alanr. Allow (file-set "foo" "foo:foo-file-set") to work.                  (apply file-set-function (file-set (second f) (and (stringp (third f)) (third f)))                          (if (stringp (third f)) (cdddr f) (cddr f))))                (when (or (eq document-types :all)                          (member (getf (cdr f) :document-type :lisp-source) document-types))                  (when function                    (if  (cheap-wild-pathname-p (assure-directory (car f)))                      (loop for ff in (logical-pathname-directory (assure-directory (car f)))                            do (apply #'lisp/fasl-function-filter ff (cdr f)))                      (apply #'lisp/fasl-function-filter (assure-directory (car f)) (cdr f)))))))))));; this version only calls function when the file exists on disk.(defmethod map-file-set-existing-files ((fs file-set) function                                     &rest map-file-set-files-keywords)  (with-fast-file-probe-and-time    (apply 'map-file-set-files fs #'(lambda(f) (when (fast-probe-file (translate-logical-pathname f))                                          (funcall function f)))                        map-file-set-files-keywords)))(defmethod iterate-over-files ((fs file-set) file-fn file-set-fn)  (flet ((assure-directory (f)           (if (and (stringp f) (char= (char f 0) #\;))             (format nil "~a:~a" (name fs) (subseq f 1))             f)))    (map-file-set-files fs file-fn :document-types '(:lisp-source) :file-set-function file-set-fn :call-with-keywords? nil)))(defvar *inside-a-load-file-sets* nil)(defvar *inside-a-load* nil)(defun load-file-set (&rest args)  (apply 'load-if-newer args));mt add checks for non-method(defun file-set-congruency-handler (gf method)  (format t "~&; (:method ~a ~a) redefining generic function arguments~&;   Arguments were ~a, now ~a."          (and method (method-name method))          (and method               (mapcar #'(lambda(spec) (if (classp spec) (class-name spec) spec))                       (method-specializers method)))          (arglist gf)          (and method (arglist method)))  (when (> (length (generic-function-methods gf)) 1)    (format t "~&;   ~a methods were removed." (length (generic-function-methods gf))))  t)(defmethod load-if-newer ((f file-set) &rest args)  (when (do-before f)    (eval (do-before f)))  (when (file-set-shared-libraries f)    (ensure-shared-libraries-installed f))  (unwind-protect    (without-egc      (let ((*defmethod-congruency-override* #'file-set-congruency-handler))        (if (or (not (and *loading-multiple-file-sets*                          (neq *loading-multiple-file-sets* t)                          (member f *loading-multiple-file-sets*)                          ))                (not *loading-multiple-file-sets*))          (progn            (when *load-file-set-verbose*              (format t "~&;Loading File set ~a~&" (name f)))            (when *loading-multiple-file-sets*               (if (eq *loading-multiple-file-sets* t)                 (setq *loading-multiple-file-sets* (list f))                (pushnew f *loading-multiple-file-sets*)))            (let ((*loading-file-set-logical-host* (name f)))              (with-file-set-cache                (flet ((it ()                         (unless (file-set-loaded-this-time f)                           (with-fast-file-probe-and-time                             (when (eq (update-binary-when f) :before)                               (update-binary f))                             (let ((loaded-as-block (maybe-load-concatenated-fasls f)))                               (flet ((lin (&rest specific-args)                                        (when (or (stringp (car specific-args)) (pathnamep (car specific-args)))                                          (update-mini-buffer-progress                                            (format nil "~a" (namestring (car specific-args)))))                                        (apply 'load-if-newer (append specific-args args))))                                 (with-compilation-unit ()                                   (iterate-over-files f (if loaded-as-block nil #'lin) #'lin)))                               (when (eq (update-binary-when f) :after)                                 (update-binary f))))                           (loading-file-set f)                           )))                  (restart-case                     (it)                    (nil () :report (lambda (stream) (format stream "Retry loading file set ~s" (name f)))                         (file-set-didnt-load f)                         (load-if-newer (name f))))))))          (when *load-file-set-verbose*            (format t "~&;Skipping redundantly loading file set ~a" (name f))))))    (when (do-after f)      (eval (do-after f)))))(defun update-mini-buffer-progress (string)  (when *top-listener*    (let* ((mini (view-mini-buffer *top-listener*))          (buf (fred-buffer mini)))      (format mini "~&~a" string)      (stream-force-output mini)      (window-show-cursor mini (buffer-line-start buf)))))  (defmethod update-binary ((f file-set))  (with-file-set-cache    (unless (file-set-loaded-this-time f)      (flet ((update (f &rest args)                (declare (ignore args))               (update-binary (make-load-file f)))             (update-file-set (f &rest args)                (declare (ignore args))               (update-binary f)))        (with-compilation-unit ()          (iterate-over-files f #'update #'update-file-set))))));; In another patch I modify the function fred. In order to not get argument mismatch warning,;; I redefine the old definition with the same arglist as the new.(defvar *old-fred* #'fred)(defun fred (&optional name new-window &rest args &aux w)  (declare (ignore args w))  (funcall *old-fred* name new-window))           (defmethod edit ((f load-file) &key (hide? t))  (if hide?    (without-interrupts     (window-hide (fred (source-name f)  nil :window-show nil)))    (ed (source-name f))))(defmethod edit ((f file-set) &key (hide? t) (include-components? nil))  (flet ((edit-file (f &rest args)           (declare (ignore args))           (ignore-errors (edit (make-load-file f) :hide? hide?)))         (edit-file-set (f &rest args)           (declare (ignore args))           (when include-components?             (edit f :hide? hide?))))    (iterate-over-files f #'edit-file #'edit-file-set)    (when hide? "Windows are hidden - See Windows menu")))(defmethod edit ((s string) &key(hide? t) (include-components? nil))  (edit (file-set s) :hide? hide? :include-components? include-components?))         (defun ccl-volume-name ()  (concatenate 'string (second (pathname-directory (truename "ccl:"))) ":"));; GBK 9/20/95 changed initialization from (list "projects:*;") to nil;; we don't want users to have to have a projects directory to use File Set(defvar *file-set-search-path* nil)(defun offer-user-choice-of-filesets (sets)  (car (select-item-from-list sets :window-title "Which file-set definition?")))(defun find-file-set-definition-on-ccl-disk (file-set-name)  (let ((them (fast-find-file :volume (ccl-volume-name) :name-is (format nil "~a-file-set.lisp" file-set-name))))    (if (null (cdr them))      (car them)      (offer-user-choice-of-filesets them))))(defun find-file-set-definition-other-than-ccl-disk (file-set-name)  (let ((disks (remove (ccl-volume-name) (mapcar 'namestring (directory "*:")) :test 'string-equal)))    (let ((them (fast-find-file :volume disks :name-is (format nil "~a-file-set.lisp" file-set-name))))      (if (null (cdr them))        (car them)        (offer-user-choice-of-filesets them)))))(defun ask-for-file-set-definition-location (file-set-name)  (message-dialog (format nil "Couldn't find the file set ~A. Please locate it, or hold shift and click ok to search all disks." file-set-name))  (if (shift-key-p)    (find-file-set-definition-other-than-ccl-disk file-set-name)    (choose-file-dialog :button-string "Here!")));; September 28,1995 alanr: patch around bug in back-translate-pathname applied to relative ;; logical paths;; 9/27/95 Kotik: changed call to DIRECTORY to have keyword arg RESOLVE-ALIASES set;;    to :SHOW-ALIAS.  This causes DIRECTORY to search within aliases to folders,;;    but return any matching pathnames using the pathname through the alias.;(eval-when (:load-toplevel :compile-toplevel :execute);  (format *error-output* "~&;; Patching around bug in back-translate-pathname in function  find-file-set-using-search-path-path - doesn't work with relative paths~%"))(defun find-file-set-using-search-path-path (path name &aux it)  (unless (logical-pathname-p path)    (setq path (or (ignore-errors (back-translate-pathname path)) path)))  (when (pathnamep path) (setq path (namestring path)))  (cond ((and (string-equal path "projects:*;") *cache-projects-file-sets?*              (let ((file-set-file (concatenate 'string name "-file-set")))                (setq it (find file-set-file *cached-projects-file-sets*                               :test 'string-equal                               :key #'(lambda(fsf) (pathname-name fsf))))))         (list it))        ((and (member (pathname-host path) '(nil :unspecific))              (= (length (pathname-directory path)) 3)              (eql (third (pathname-directory path)) :wild-inferiors))         (let ((fast-found                (fast-find-file :volume (second (pathname-directory path))                                :name-matches (concatenate 'string name "-file-set.lisp"))))           (and fast-found (if (= (length fast-found) 1)                              (car fast-found)                             (offer-user-choice-of-filesets fast-found)))))        (t (directory (merge-pathnames (concatenate 'string name "-file-set.lisp") path)                      :resolve-aliases :show-alias))));; 9/27/95 Kotik: take CAR of result returned by select-item-from-list (defun find-file-set-definition-on-search-path (name)  (loop for dir in *file-set-search-path*        for set-paths = (find-file-set-using-search-path-path dir name)        do         (when set-paths          (return-from find-file-set-definition-on-search-path             (if (null (cdr set-paths))              (car set-paths)              (car (select-item-from-list set-paths :window-title "Which file-set definition?")))))));; Friday August 23,1996 alanr: fixed bug when null pathname (defun maybe-add-path-directory-to-file-set-search-path (path)  (pushnew (make-pathname :directory (append                                       (or (butlast (pathname-directory path))                                          '(:absolute))                                      (list "*"))                          :host (pathname-host path))           *file-set-search-path*           :test #'(lambda(a b)                     (multiple-value-bind                        (result errorp)                       (or (equalp a b)                           (ignore-errors                            (equalp (truename a) (truename b))))                       (and (not errorp) result)))))                                                   ;; get the definition for file set.(defmethod file-set ((name string) &optional path (interact? t))  (update-mini-buffer-progress (format nil "Finding file-set ~a..." name))  (flet ((loadit (path)           (let ((*package* (find-package :ccl)))             (load-if-newer (make-load-file path :never-compile? t)))           (assert (file-set-defined? name) ()                    "The file ~A was loaded, but file set ~A was not defined"                    path name)           (maybe-add-path-directory-to-file-set-search-path path)           (setf (origin (file-set-defined? name)) path)           (return-from file-set (file-set-defined? name))))    (let ((exists (named-file-set name)))      (if (and exists (origin exists) (probe-file (origin exists)))        (loadit (origin exists))        (if (and path (probe-file path))          (loadit path)          (loadit           (or (find-file-set-definition-on-search-path name)               (and *file-set-search-common-disks?* (find-file-set-definition-on-ccl-disk name))               (and *file-set-search-common-disks?* (and interact? (ask-for-file-set-definition-location name)))               (error "Can't find file set ~a" name))))))));; keep top-level-fileset-cache(defmethod file-set :around ((name string) &optional path interact?)  (declare (ignore path interact?))  (let ((cache (and *file-sets-cache* (gethash name *file-sets-cache*))))    (or cache         (if *file-sets-cache*           (setf (gethash name *file-sets-cache*) (call-next-method))          (call-next-method)))))        (defun file-set-defined? (name)  (find name (all (class-prototype (find-class 'file-set))) :key 'name :test 'string-equal));; 9/25/95 Kotik: don't set up hard-wired translations for .A files(defun load-relative-logical-host (name &key (separate-fasls? t) before after)  (let* ((load-path *loading-file-source-file*)         (raw (namestring                (make-pathname                 :directory (pathname-directory (truename load-path)))))         (fasl (list (format nil "~A:**;*.fasl" name)                      (if (= fasl-version 65316)                       (format nil "~Afasl:**:*.*" raw)                       (format nil "~Afasl:v~afasl:**:*.*" raw fasl-version)                       )))         (pfsl (list (format nil "~A:**;*.pfsl" name)                        (format nil "~Afasl:pfsl-v~a:**:*.*" raw fasl-version)                       ))         (other (list (format nil "~A:**;*.*" name)                      (format nil "~A**:*.*"  raw))))    (set-logical-pathname-translations      name     (if separate-fasls?        (append before (list fasl pfsl other) after)       (append before (list other) after)))))(defun ln (&rest args)    (eval-enqueue `(progn                   (funcall 'load-if-newer ,@args)))  (values));; same as ln but makes the load-pointers-form(defun pln (&rest args)  (eval   `(def-load-pointers ,(intern (string-upcase (format nil "load-pointers-load-file-set-~a" (car args)))) ()      (ln ,@args))));; 10/9/95 Kotik: change to print out name of .fasl being deleted, not .lisp.;;    Also, change format of format messages so each file takes 1 line not 2.(defmethod delete-fasls ((file pathname) &key recursive? (verbose? t))  (declare (ignore recursive?))  (loop for f in (directory (merge-pathnames *fasl-suffix* file))        do         (when verbose?           (format t "~&;; Deleting ~a~%" (namestring (back-translate-pathname f))))        (delete-file f)))(defmethod delete-fasls ((name string) &key recursive? (verbose? t))  (if (or (cheap-wild-pathname-p name) (pathname-directory name) (neq (pathname-host name) :unspecific))    (delete-fasls (pathname name) :recursive? recursive? :verbose? verbose?)    (delete-fasls (file-set name):recursive? recursive? :verbose? verbose?)))(defmethod delete-fasls ((fs file-set) &key recursive? (verbose? t))  (declare (ignore args))  (flet ((doit (file) (delete-fasls file :recursive? recursive? :verbose? verbose?)))    (iterate-over-files fs #'doit (if recursive? #'doit nil))))(defmethod invalidate-source ((fs file-set))  (flet ((inv (f &rest args)           (declare (ignore args))           (invalidate-source f)))    (iterate-over-files fs #'inv nil)))(defun efs (file-set)  (ed (format nil "~a:~a-file-set.lisp"              (name (file-set file-set))              (name (file-set file-set)))))(defmethod all-fasls-filename ((f file-set))  (format nil "~a:~a-all-fasls~a" (name f) (name f) *fasl-suffix*))(defmethod concatenate-fasls ((f file-set))  (let ((all nil))    (flet ((do-file (f &rest args)              (declare (ignore args))             (with-slots (binary-truename binary-name) (make-load-file f)               (let ((binary                      (or                       (fast-probe-file binary-truename)                       (probe-file binary-name))))                 (push binary all))))           (do-file-set (f &rest args)              (declare (ignore f args)) nil))      (iterate-over-files f #'do-file #'do-file-set)      (fasl-concatenate (all-fasls-filename f) (reverse all))      (set-file-write-date (all-fasls-filename f) (get-universal-time))      )))(defmethod maybe-load-concatenated-fasls ((f file-set))  (let ((catfasl-file (all-fasls-filename f)))    (if (probe-file catfasl-file)      (progn         (load-if-newer (make-load-file catfasl-file))        t)      nil)))(defmethod freeze-file-set ((f file-set))  (ignore-errors (delete-file (all-fasls-filename f)))  (update-binary f)  (concatenate-fasls f)  (load-if-newer f))(defmethod freeze-file-set ((s string))  (freeze-file-set (file-set s)));; kotik: 10/5/95 controls whether file sets are automatically reloaded;;                when an application is launched.(defvar *load-newer-filesets-on-restart?* t);; kotik: 10/5/95 reload file sets only if *load-newer-filesets-on-restart?*(defmacro when-restart-load-newer (fileset)  (let ((*no-not-now-please* (gensym)))    `(def-load-pointers ,(gensym (string fileset)) ()       (unless (or (boundp ',*no-not-now-please*)                   (not *load-newer-filesets-on-restart?*))         (eval-enqueue `(progn                           (load-if-newer ,,fileset)                          (setq ',,*no-not-now-please* t))))))); Tuesday December 31,1996 alanr removed was for transition only.#|;; update any existing load-files.(defvar *using-mac-file-write-data*)(when (not (boundp '*using-mac-file-write-data*))  (loop for i in (all (class-prototype (find-class 'load-file)))        do (setf (loaded-time i) (universal-to-mac-time (loaded-time i))))  (setq *using-mac-file-write-data* t))|#