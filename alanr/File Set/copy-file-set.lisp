;; ****************************************************************;;;; Author: Gordon Kotik, Interval Research;;;; Created: September 1995;; ;; Modification History:;;;; 12/29/95 Kotik: fixed a couple of bugs with copy-file-set.;; ;; ****************************************************************(in-package :ccl);; need to implement :document-types :ask (write general fn get-document-types-from-user;; target-folder cannot be a logical pathname.;; 12/29/95 Kotik: handles folders that don't end in #\: now, and doesn't create;;   folders for sub file sets if none of the files in the sub file set are copied.;; 12/5/95 Kotik: removed explicit copy of file set definition file, this is now done;;   as part of the map-file-set-files.(defmethod copy-file-set ((fs file-set) target-folder &key                            (document-types :all)                            (recursive? t)                            (verbose? t)                            (top-source-folder nil)                            (top-target-folder nil))  (setq target-folder (namestring (translate-logical-pathname target-folder)))  (unless (eq (class-name (class-of fs)) 'file-set)    (error "~%COPY-FILE-SET: ~S is not a fileset" fs))  (when (pathname-name target-folder)    (setq target-folder (format nil "~A:" target-folder))    (unless (probe-file target-folder)      (error "~%COPY-FILE-SET: can't copy to non-existent folder ~A" target-folder)))  (when verbose?     (format t "~2%Copying FILE SET ~S to folder ~A..." (name fs) target-folder))  (flet ((truenamestring (pathname) (namestring (truename pathname))))    (let ((file-set-def-file (truenamestring (origin fs)))          (*copied-file-sets nil))      (declare (special *copied-file-sets))      (unless top-target-folder         (setq top-target-folder (namestring target-folder))        (setq top-source-folder (subseq file-set-def-file 0                                        (+ 1 (position #\: file-set-def-file :from-end t)))))      (labels ((pathname-relative-to (file-str dir-str)                 (unless (string= file-str dir-str :end1 (length dir-str))                   (error "~%COPY-FILE-SET: file ~s is not in ~%  directory ~s" file-str dir-str))                 (subseq file-str (length dir-str)))               (target-truename-str (source-truename-str)                 (let ((relative-pathname (pathname-relative-to source-truename-str top-source-folder)))                   (format nil "~A~A" top-target-folder relative-pathname)))               (ensure-containing-folder-exists (truename-str)                 (let ((containing-dir (make-pathname :defaults (pathname truename-str) :name nil :type nil)))                   (unless (probe-file containing-dir) (create-directory containing-dir))))               (copy-file-set-file (file)                 (let* ((file-truename-str (truenamestring file))                        (target-truename-str (target-truename-str file-truename-str)))                   (ensure-containing-folder-exists target-truename-str)                   (when verbose?                     (format t "~%Copying ~A ~%     to ~A" file-truename-str target-truename-str))                   (if (probe-file file-truename-str)                     (copy-file file-truename-str target-truename-str :if-exists :supersede)                     (format t "~%COPY-FILE-SET: can't copy non-existent file ~A" file-truename-str))))               (copy-sub-file-set (sub-fs)                 (unless (member sub-fs *copied-file-sets)                   (let* ((sub-fs-def-file (truenamestring (origin sub-fs)))                          (sub-fs-source-folder                            (truenamestring (make-pathname :defaults (pathname sub-fs-def-file)                                                          :name nil :type nil)))                          (sub-fs-target-folder (format nil "~A~A" top-target-folder                                                         (pathname-relative-to sub-fs-source-folder                                                                              top-source-folder))))                     (copy-file-set sub-fs sub-fs-target-folder                                    :top-source-folder top-source-folder                                    :top-target-folder top-target-folder                                    :document-types document-types                                    :verbose? verbose?                                    :recursive? recursive?)))))        (map-file-set-files  fs #'copy-file-set-file                              :file-set-function (if recursive? #'copy-sub-file-set nil)                             :document-types document-types)        (push fs *copied-file-sets)))))