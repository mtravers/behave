Load-newer.lisp Alan Ruttenbergalanr@media.mit.eduLoad-newer defines a number of functions to help with management of loadingand recompiling files. The function load-if-newer loads a file only if thesource for it is newer than the last time the file was loaded. File-sets aredefined as a way to group a set of files together.(make-load-file <pathname>)Creates a new load file (clos) object, or returns a preexisting objectcorresponding to this pathname. The object has slots for the source-name,binary-name, and the date when the file was last loaded.(load-if-newer <load-file>)Loads load-file, if the source code has changed since the last time load-filewas loaded.(load-if-newer <pathname>)Equivalent to (load-if-newer (make-load-file <pathname>))(file-set <string>)Returns a file-set object corresponding to string. The file set definitionfile must be named <string>-file-set.lisp.The file set definition file must include a form such as:(make-instance 'file-set  :define-logical-host? t  :name "customizations"  :files  '((file-set "patches")    ("customizations:macros" :load-source-invalidates ("customizations:code;*"))    ";code;*"))This form defines a file set named "customizations", which first loadsanother file-set called "patches", and then loads all the files in thedirectory "customization:code;". The :define-logical-host? keyword specifiesthat a logical pathname should be created corresponding to the name of thefile set, and hoving as its root directory the directory where the file setdefinition lives. The file can have any other forms, (for instance a nonstandard logical pathname definition). The only constraint is that after thefile is loaded there better be a file set of the same name as string defined.If the pathname start with ";" then it is interpreted to be in thelogical host that is defined.The file-set definition file is named <string>-file-set.lisp. The definitionfile is searched for in the directories specified in the list*file-set-search-path* initially, '("projects:**;" "ccl:""ccl:file-sets;**;"). If the definition is not found there, then thedirectories in *module-search-path* are searched. Wildcarded pathnames ineither the file list or in the search path are properly expanded. This is becauseload-if-newer does a (directory) call on each pathname and loads all that match.If the keyword :load-source-invalidates is followed by a list of files(wildcarded, or file-sets), then those file have their write-date changed tothe current time whenever the source (lisp code) for the specified file isloaded. This is a way to express macro dependency. Since those files have arecent write-date, they will be reloaded, and recompiled.(load-if-newer (file-set <string>))Loads the file named <string>.(load-if-newer <string>)If <string> has a pathname-directory, then the file is loaded, if not thestring is interpreted as a file-set.(update-binary (file-set <string>))(update-binary <pathname>)Compiles any lisp files where the lisp file is newer than the binary file, orthe binary file doesn't exist.(edit <file-set> &key hide? t) Edits all the files in file-set. If hide? is t, then hides all the windowsinitially.A file set menu is added to the menubar, with entries hierarchical menus whichcorrespond to the files in the file set. Selecting the filename opens themin a fred buffer. Selecting the name of the file set opens the file set definition.If you hold down the option key while do the folder containing the selecteditem is opened in the finder. You put this in your init file to bootstrap it. It will find load-if-newerwherever it is, load it, and then use it to load the rest of it. This also needsthe file set folder "finder-interact". Put that in the same folder as the file setfolder is in.;; ****************************************************************;; Bootstrap load-if-newer;;;; ****************************************************************#+ccl-3 (defconstant $iovrefnum 22)#+ccl-3 (defconstant $iopbsize 122)#+ccl-3 (defconstant $iofilename 18)(unless (fboundp 'fast-find-file)  (defun fast-find-file (&key (volume "ccl:") (name-is "load-newer.lisp") (max-matches 20)                                  (search-buffer-size 16384))    (let ((search-criteria (+ #$fsSBFlAttrib #$fsSBfullName))          (match-results (#_newptr (* max-matches (record-length :fsspec))))          (search-buffer (#_newptr search-buffer-size))          )      (declare (dynamic-extent match-results search-buffer))      (rlet ((paramblock :hparamblockrec) (searchlow :cinfopbrec) (searchhigh :cinfopbrec))        (with-pstr (namestr name-is)          (setf (rref paramblock hparamblockrec.ioCompletion) (%null-ptr))          (setf (rref paramblock hParamblockrec.ioNamePtr) (%null-ptr))          (setf (rref paramblock hParamblockrec.iovrefnum)                 (%stack-iopb (pb np) (%path-to-iopb volume pb) (%get-signed-word pb $iovrefnum)))          (setf (rref paramblock hParamblockrec.iomatchptr) match-results)          (setf (rref paramblock hParamblockrec.ioReqMatchCount) max-matches)          (setf (rref paramblock hParamblockrec.iosearchbits) search-criteria)          (setf (rref paramblock hParamblockrec.iosearchinfo1) searchlow)          (setf (rref paramblock hParamblockrec.iosearchinfo2) searchhigh)          (setf (rref paramblock hParamblockrec.ioSearchTime) 0)          (setf (rref paramblock hParamblockrec.ioCatPosition.initialize) 0)          (setf (rref paramblock hParamblockrec.ioOptBuffer) search-buffer)          (setf (rref paramblock hParamblockrec.ioOptBufSize) search-buffer-size)          (setf (rref searchlow cinfopbrec.ioNamePtr) namestr)          (setf (rref searchlow cinfopbrec.ioFlAttrib) 0)          (setf (rref searchhigh cinfopbrec.ionameptr) (%null-ptr))          (setf (rref searchhigh cinfopbrec.ioFlAttrib) #x10)          (assert (= -39 (#_PBCatSearch  paramblock)) ()                  "error with pbcatsearch")          (loop for i from 0 below (rref paramblock hparamblockrec.ioActMatchCount)                collect (%path-from-fsspec (%inc-ptr match-results (* (record-length :fsspec) i)))))))))(defun most-recent-path (paths)  (and paths (let ((dates (mapcar 'file-write-date paths)))               (nth (position (apply 'max dates) dates) paths))))(unless (fboundp 'load-if-newer)  (let ((load-if-newer-file (most-recent-path (fast-find-file :name-is "load-newer.lisp"))))    (assert load-if-newer-file () "Can't find load-newer.lisp on same disk as mcl:")    (load (merge-pathnames "cinfopbrec.lisp" load-if-newer-file))    (load load-if-newer-file)))(load-if-newer "fileset")