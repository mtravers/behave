;;; MT's patches for Alanr's load-if-newer(in-package :ccl)#|Todo:- make fileset menu a submenu- options for forcing or skipping compilation- flush disk-wide search.- when a fileset is made, replace old one on ALL variable- filesets seem to only point to names, not file objects.  Maybe this should be fixed?You have to explicity call load-if-newer-menu-install to put a filesetin the menu. It's very aggressive when it can't find a sub-fileset.Does not apply auto-compile, versioned fasl directories to (load-newer <file>)versions fasls is done in load-relative-logical-host, which appears toonly be used from files-sets...argh.  And I think it's only used if you use the:define-logical-host? t option. Double argh.  OK, fixed this by using different extensions.Special hack: ";" before a file means "relative to the logical host. Argh.(ln <file>) ought to have the same behavior as (ln <fileset>). In particular,it should compile the file if necessay, and stick it on the menu (which willneed to be retitled.)It would be neat if this package could advise load and track all files loaded,including those by other mechanisms, and still supply the menu functionalityand perhaps others.  Let's say you bind a variable around a call tosome-other-loader to tell it what fileset it is surreptiously a part of. -- perhaps the require tree should be made visible in the menus (or something like that)The new package ought to include a tiny loader for including with distributions,where the full package might not be desireable.6/27/95 11:42update-all-file-sets will lose if there is a function defined in two files withthe idea that the later definition will override the earlier. If the earlier ischanged, it will get loaded and shadow the later one.  Not sure how to fix thisshort of having complex load dependencies.|#;;; patch out loading of cinfopbrec.lisp in bootstrap.lisp and in fileset def.(defun ln-require (module)  (unless (member (string module) *modules* :test #'string=)    (let ((pathname (ccl::find-module-pathnames (string module))))      (cond ((null pathname)             (error "Module ~A not found" module))            ((listp pathname)             (error "whoops can't deal"))            (t              (let ((load-file (make-load-file pathname)))               (update-binary load-file)               (ln load-file)); provide remembers the loading path, so this confuses things             ;          (provide module)             )))));;; experiment in terror #|  (integrated into load-newer, it seems)(defvar *fasl-extension*  (case fasl-version    (65316 ".fasl")#-:powerpc    (65320 ".fasl3")#+:powerpc    (65320 ".pfsl")    (65321 ".fsl3")                     ; new in 3.1f1 -- may need PPC conditional depending on what 4 uses    (65328 ".fsl4")    (t (error "unknown fasl type ~A" fasl-version))))(defmethod initialize-instance :after ((f load-file) &key)  (setf (source-name f) (namestring (merge-pathnames ".lisp" (source-name f)))            (source-truename f) (mac-namestring (translate-logical-pathname (source-name f)))     ; mac-namestring was namestring        (binary-name f) (namestring (merge-pathnames *fasl-extension* (pathname (source-name f))))        (binary-truename f) (mac-namestring (translate-logical-pathname (binary-name f))))    ; mac-namestring was namestring  (push f (all f)))(defun load-if-newer-directory (directory)  (mapcar 'load-if-newer           (sort (union (logical-pathname-directory (merge-pathnames ".lisp" directory))                       (logical-pathname-directory (merge-pathnames *fasl-extension* directory))                       :test 'equalp)                 #'string-lessp :key #'namestring)));;; new: handle multiple fasl versions(defun load-relative-logical-host (name &key (separate-fasls? t) before after)  (let* ((load-path *loading-file-source-file*)         (raw (namestring                (make-pathname                 :directory (pathname-directory (truename load-path)))))         (fasl (list (format nil "~A:**;*~A" name *fasl-extension*)                     (if (= fasl-version 65316)                       (format nil "~Afasl:**:*.*" raw)                       (format nil "~Afasl-v~a:**:*.*" raw fasl-version)                       )))         (objects (list (format nil "~A:**;*.a" name)                         (format nil "~Ac-object-files:**:*.*"  raw)))         (other (list (format nil "~A:**;*.*" name)                      (format nil "~A**:*.*"  raw))))    (set-logical-pathname-translations      name     (if separate-fasls?        (append before (list fasl  objects other) after)       (append before (list  objects other) after)))))|#;;; new function(defun update-all-file-sets ()  (mapc #'load-if-newer (mapcar #'name (all-file-sets))))       ; name is necessary. Blame Alanr;;; new function, not yet used (perhaps replace update-all-file-sets with this)(defun update-all-files ()  (mapc #'load-if-newer (loaded-files)))(defun all-file-sets ()  (all (class-prototype (find-class 'file-set))));;; allow file-set definitions to live anywhere, be loaded "by hand", and still work.(defmethod initialize-instance ((f file-set) &key (define-logical-host? t) interface-files)  (call-next-method)  (when (and (not (origin f)) (car *loading-files*))    (setf (origin f) (car *loading-files*)))  (push f (all f))  (when define-logical-host?    (load-relative-logical-host (name f)));;; what the hell was this?  '(ensure-interface-installed    (loop for path in interface-files append (resolve-pathname-spec f path)))); doesn't work in MCL2#-CCL-3(defun fast-file-write-date (name)  (file-write-date name));;; may not work, why take the chance#-CCL-3(defun fast-probe-file (name)  (probe-file name))#|   changed a lot in new version;; mt -- don't try full-disk scan.  ;; get the definition for file set. Look in require directories, and *file-set-search-path*(defmethod file-set ((name string) &optional path (interact? t))  (let ((set-definition-name (concatenate 'string name "-file-set.lisp"))         (search-path (append *file-set-search-path* *module-search-path*)))    (labels ((loadit (path)               (let ((*package* (find-package :ccl)))                 (load-if-newer (make-load-file path :never-compile? t)))               (assert (file-set-defined? name) ()                        "The file ~A was loaded, but file set ~A was not defined"                        path name)               (setf (origin (file-set-defined? name)) path)               (return-from file-set (file-set-defined? name)))             (try-search-path (&optional path)               (loop with search-path = (or path search-path)                     for dir in search-path                     for set-paths = (directory (merge-pathnames set-definition-name dir))                     do                      (when set-paths                       (loop for p in set-paths                             do (pushnew (make-pathname :directory (append                                                                     (butlast (pathname-directory p))                                                                    (list "*")))                                         *file-set-search-path*                                         :test #'(lambda(a b)                                                   (multiple-value-bind                                                      (result errorp)                                                     (or (equalp a b)                                                         (ignore-errors                                                          (equalp (truename a) (truename b))))                                                     (and (not errorp) result)))))                       (return-from file-set (loadit (car set-paths)) ))))             (try-ccl-disk ()               (when *load-verbose* (format *error-output* "~&;Looking for ~A in ~A~%" set-definition-name                                             (ccl-host-wild-pathname)))               (try-search-path (list (ccl-host-wild-pathname))))             (try-really-hard () (try-search-path (list (all-wild-pathname))))             (try-everything () (try-search-path) '(try-ccl-disk) (try-really-hard) (try-asking))             (try-asking ()               (message-dialog (format nil "Couldn't find the file set ~A. Please locate it." name))               (loadit (choose-file-dialog :button-string "Here it is!"))))      (let ((exists (named-file-set name)))        (if (and exists (origin exists) (probe-file (origin exists)))          (loadit (origin exists))          (if path            (if (probe-file path)              (loadit path)              (if (y-or-n-dialog "File set definition path does not exist. Try to find it?")                (try-everything)                (return-from file-set nil)))            (progn              (try-search-path)              ; (try-ccl-disk)              (if interact?                (progn                  (if (y-or-n-dialog (format nil "No file ~A was found. Look for it on all disks?~%~%Already checked: ~A and ~A"                                             set-definition-name                                             search-path                                             (merge-pathnames (ccl-host-wild-pathname) set-definition-name))                                     :size #@(400 200))                    (try-really-hard))                  (try-asking))                nil))))))))|#;;; for newer stuff;; get the definition for file set.(defmethod file-set ((name string) &optional path (interact? t))  (update-mini-buffer-progress (format nil "Finding file-set ~a..." name))  (flet ((loadit (path)           (let ((*package* (find-package :ccl)))             (load-if-newer (make-load-file path :never-compile? t)))           (assert (file-set-defined? name) ()                    "The file ~A was loaded, but file set ~A was not defined"                    path name)           (maybe-add-path-directory-to-file-set-search-path path)           (setf (origin (file-set-defined? name)) path)           (return-from file-set (file-set-defined? name))))    (let ((exists (named-file-set name)))      (if (and exists (origin exists))        (if (probe-file (origin exists))          (loadit (origin exists))          (progn (warn "Can't find definition for fileset ~A; should be in ~A (~A)"                       name (origin exists) (mac-namestring (origin exists)))                 exists))               ; use old definition        (if (and path (probe-file path))          (loadit path)          (loadit           (or (find-file-set-definition-on-search-path name)               (find-file-set-definition-on-ccl-disk name)               (and interact? (ask-for-file-set-definition-location name)))))))));;; new function;;; get ahold of the file objects (I wish the fileset just had a pointer to them)(defun fileset-load-files (fileset)  (let ((result nil))    (iterate-over-files (file-set fileset)                        #'(lambda (f) (push (make-load-file f) result))                        #'identity)    result))(defmethod file-set ((f file-set) &optional path (interact? t))  (declare (ignore path interact?))  f);;; didn't work if path had hull directory(defun maybe-add-path-directory-to-file-set-search-path (path)  (pushnew (make-pathname :directory (if (pathname-directory path)                                       (append                                         (butlast (pathname-directory path))                                        (list "*"))                                       :wild)                          :host (pathname-host path))           *file-set-search-path*           :test #'(lambda(a b)                     (multiple-value-bind                        (result errorp)                       (or (equalp a b)                           (ignore-errors                            (equalp (truename a) (truename b))))                       (and (not errorp) result)))))