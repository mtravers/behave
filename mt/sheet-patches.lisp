(in-package :ccl);;; Additions and modifications to the Sheet package(defclass sheet-window (a-window)  (sheet-view))(defmethod initialize-instance :after ((w sheet-window) &rest ignore)  (with-slots (sheet-view view-size) w    (setf sheet-view (make-instance 'sheet-view ; 'textedit-basic-sheet -- screws up stages for some reason.                       :view-size view-size                       :view-container w))))(defmethod set-view-size :after ((w sheet-window) h &optional v)  (declare (ignore h v))  (with-slots (sheet-view view-size) w    (unless (= view-size (view-size sheet-view))      (set-view-size sheet-view view-size))));;; add dont-erase keyword;;; add better error handling#|  3/24/97 22:36 this is obso in new sheet system(eval-when (:load-toplevel :execute)  (defmethod update-gworld ((g gworld) &key colortable depth size gdevice dont-erase)    (assert (gworld g) () "Gworld should be non nil here!")    (rlet ((gw :pointer))      (%put-ptr gw (gworld g))      (let ((err (#_updategworld gw                  (setf (depth g) (or depth (depth g)))                  (rect (setf (size g) (or size (size g))))                  (setf (colortable g) (or colortable (colortable g)))                  (setf (gdevice g) (or gdevice (gdevice g)))                  (gworld-update-method g))))        (if (minusp err)          (error "updategworld failed ~D" err)        ;; do a setf of the macptr, so that we preserve whatever flags we had        ;; primarily the disposegworld flag, if it exists.          (%setf-macptr (gworld g) (%get-ptr gw))          )))    (with-focused-gworld (g)      (let ((r (rect (or size (size g) ))))        (#_cliprect r)        (unless dont-erase          (#_eraserect r))        ))))|#;;; from aviews - unspecialize second arg so nil is handled(defmethod set-view-container ((view a-base) new-container &aux                               (old-container (view-container view)))  (when (neq new-container old-container)    (when new-container      (when (or (eq new-container view)                (view-contains-p view new-container))        (error "Attempt to make ~s contain itself." view)))    (without-interrupts     (when old-container       (invalidate-view view t)       (setf (slot-value old-container 'view-subviews)             (delete view (view-subviews old-container) :test #'eq))       (when (view-sheet view)         (remove-view-from-sheet view))       (set-view-container-slot view nil))     (when new-container       (let ((siblings (view-subviews new-container))             (containing-sheet (if (sheet? new-container)                                  new-container                                 (view-sheet new-container))))         (vector-push-extend view siblings)         (set-view-container-slot view new-container)         (when containing-sheet           (install-view-in-sheet view containing-sheet)           (invalidate-view view)))))    (refocus-view view))  new-container);;; Obso or unfinished#|(defmethod initialize-instance :after ((w sheet-window) &rest ignore)  (with-slots (sheet-view view-size) w    (setf sheet-view (make-instance 'textedit-basic-sheet ; 'textedit-basic-sheet -- screws up stages for some reason.                       :depth 8                       :view-size view-size                       :view-container w))));;; Textedit stuff(load "sheet:examples;textedit")(load "sheet:examples;te-sheet")(defmethod view-click-event-handler ((v te-basic) where)  (with-focused-view v    (do ((start (#_tegetoffset where (textedit-handle v)))         current         (end -1))     ((not (mouse-down-p)))     (setf current (#_tegetoffset (view-mouse-position v) (textedit-handle v)))     (unless (= current end)       (setf end current)       (#_tesetselect (min start end) (max start end) (textedit-handle v))       (invalidate-view v t)       (window-update-event-handler (view-window v))))))(defmethod initialize-instance :after ((w sheet-window) &rest ignore)  (with-slots (sheet-view view-size) w    (setf sheet-view (make-instance 'textedit-basic-sheet                       :view-size view-size                       :view-container w                       :depth 8))))|#;;; hack it so users don't need to know about the sheet-view...later;(defmethod set-view-container (subview (superview sheet-window));  (set-view-container (subview (slot-value superview 'sheet-view))))